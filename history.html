<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>History</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="js/firebase-config.js"></script>

  <style>
    :root{ --bg:#fffafc; --ink:#222; --muted:#6b6b6b; --card:#ffffff; --brand:#88a58d; --red:#f28b82; --green:#a5d6a7; --blue:#8ab4f8; --amber:#fbc02d; --purple:#d15fa7; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:"Segoe UI",system-ui,-apple-system,sans-serif}
    header{position:sticky;top:0;background:var(--bg);z-index:10;padding:12px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;gap:12px}
    header h1{font-size:18px;margin:0;font-weight:600}
    header .spacer{flex:1}
    header button{border:none;background:var(--brand);color:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}

    .cards{display:flex;gap:10px;overflow:auto;padding:12px 12px 4px}
    .card{min-width:160px;background:var(--card);border:1px solid #eee;border-radius:14px;padding:10px;box-shadow:0 2px 6px rgba(0,0,0,.04)}
    .card h3{font-size:12px;color:var(--muted);margin:0 0 6px}
    .card .value{font-size:22px;font-weight:700}
    .card .sub{font-size:12px;color:var(--muted)}

    .section{padding:8px 12px}
    .section h2{font-size:16px;margin:8px 0}

    .ribbons{display:flex;flex-direction:column;gap:10px}
    .ribbon{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px}
    .ribbon .label{font-weight:600;font-size:13px;margin-bottom:6px;display:flex;justify-content:space-between;color:var(--muted)}
    .bar{position:relative;height:10px;background:#f3f3f3;border-radius:999px;overflow:hidden}
    .band{position:absolute;top:0;bottom:0;border-radius:999px}

    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted)}
    .swatch{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:4px;vertical-align:middle}

    .grid{display:grid;grid-template-columns:1fr;gap:12px;padding:8px 12px}
    @media(min-width:560px){.grid{grid-template-columns:1fr 1fr}}

    .panel{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px}
    .panel h3{font-size:14px;margin:0 0 4px}
    .panel .caption{font-size:12px;color:var(--muted);margin-bottom:8px}
    .kpi{display:flex;align-items:baseline;gap:8px;margin-bottom:6px}
    .kpi .big{font-size:24px;font-weight:800}
    .kpi .small{font-size:12px;color:var(--muted)}
    .reasons{font-size:12px;color:var(--ink);display:flex;flex-direction:column;gap:4px;margin-top:6px}
    .chip{display:inline-block;background:#f1f3f4;border:1px solid #e2e6ea;border-radius:999px;padding:2px 8px;margin-right:6px;font-size:12px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .line{font-size:12px}

    /* Sex coverage pills in ribbons */
    .pills{display:flex;gap:4px;margin-top:6px}
    .pill{width:10px;height:10px;border-radius:50%;background:#ddd}
    .pill.on{background:var(--blue)}

    /* Matrices */
    .matrix{width:100%;border-collapse:collapse;font-size:12px;margin-top:6px}
    .matrix th,.matrix td{border:1px solid #eee;padding:6px;text-align:center}
    .matrix th{background:#fafafa;font-weight:600;color:var(--muted)}
    .ok{color:#2e7d32;font-weight:700}
    .no{color:#c62828;font-weight:700}

    /* Surge strip */
    #surgeCanvas{width:100%;height:90px;border:1px solid #eee;border-radius:8px;background:#fff}

    @media print{ header, .filterBtn, .exportBtn, .legend {display:none!important} .cards{flex-wrap:wrap} .card{min-width:0;width:24%} }
  </style>
</head>
<body>
  <header>
    <h1>History</h1>
    <div class="spacer"></div>
    <button class="filterBtn" id="filterBtn">Filters</button>
    <button class="exportBtn" id="exportBtn">Share Summary</button>
  </header>

  <div class="cards" id="cards"></div>

  <div class="section">
    <h2>Completed Cycles</h2>
    <div class="ribbons" id="ribbons"></div>
    <div class="legend">
      <span><span class="swatch" style="background:var(--red)"></span>Period</span>
      <span><span class="swatch" style="background:var(--amber)"></span>Fertile</span>
      <span><span class="swatch" style="background:var(--purple)"></span>Surge</span>
      <span><span class="swatch" style="background:var(--blue)"></span>Ovulation</span>
      <span><span class="swatch" style="background:var(--green)"></span>Luteal</span>
    </div>
  </div>

  <div class="section"><h2>Insights & Trends</h2></div>
  <div class="grid">
    <!-- LH Surge Day -->
    <div class="panel">
      <h3>LH surge day (CD)</h3>
      <div class="caption" id="surgeStats">—</div>
      <canvas id="surgeCanvas"></canvas>
      <div id="surgeNotes" class="reasons"></div>
    </div>

    <!-- BBT Rise per cycle -->
    <div class="panel">
      <h3>BBT rise per cycle</h3>
      <div class="caption" id="riseStats">—</div>
      <div id="riseList" class="reasons"></div>
    </div>

    <!-- LPD risk -->
    <div class="panel">
      <h3>LPD risk (low progesterone)</h3>
      <div class="caption">Flag if <span class="mono">luteal &lt; 9d</span> OR <span class="mono">rise &lt; 0.30 °C</span></div>
      <div class="kpi"><div id="lpdBig" class="big">—</div><div id="lpdSmall" class="small"></div></div>
      <div id="lpdReasons" class="reasons"></div>
      <table class="matrix" id="lpdMatrix"></table>
    </div>

    <!-- Anovulation -->
    <div class="panel">
      <h3>Anovulation suspect</h3>
      <div class="caption">Flag if no surge ≥0.75/“Surge” AND no sustained shift (≥3 temps &gt; coverline+0.10 on DPO3–6)</div>
      <div class="kpi"><div id="anovBig" class="big">—</div><div id="anovSmall" class="small"></div></div>
      <div id="anovReasons" class="reasons"></div>
      <table class="matrix" id="anovMatrix"></table>
    </div>

    <!-- Sex timing -->
    <div class="panel">
      <h3>Sex timing — target coverage</h3>
      <div class="caption" id="sexStats">Target days −2, −1, 0 (3/3 = 100%)</div>
      <div id="sexBreak" class="line"></div>
      <div id="sexPills" class="reasons"></div>
    </div>
  </div>

  <!-- Filters sheet -->
  <div class="sheet" id="sheet">
    <div class="grab"></div>
    <div class="content">
      <div class="row"><label>Include anovulatory cycles (length stats)</label><input type="checkbox" id="incAnov" checked></div>
      <div class="row"><label>Only cycles with BBT data</label><input type="checkbox" id="bbtOnly"></div>
      <div class="row"><label>Range: last N cycles</label><input type="number" id="lastN" min="1" max="36" value="12" style="width:70px"></div>
      <div class="row"><button id="applyFilters">Apply</button></div>
    </div>
  </div>

<script>
// ===== Date utils =====
function toUTCmid(d){ return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); }
function addDays(d,n){ const x=new Date(d.getTime()); x.setDate(x.getDate()+n); return x; }
function dayDiff(a,b){ if(!(a instanceof Date)||!(b instanceof Date)) return 0; const A=toUTCmid(a), B=toUTCmid(b); return Math.max(0, Math.floor((B-A)/86400000)); }
function iso(d){ return (d instanceof Date && !isNaN(d.getTime())) ? d.toISOString().slice(0,10) : '—'; }

// ===== parse dates =====
function parseAnyDate(v){
  if(v==null) return null;
  if(v instanceof Date) return isNaN(v.getTime())? null : v;
  if(typeof v==='number'){ const d=new Date(v); return isNaN(d.getTime())? null : d; }
  if(typeof v==='object'){
    if(typeof v.toDate==='function'){ try{ const d=v.toDate(); return (d instanceof Date && !isNaN(d.getTime()))? d : null; }catch(_){} }
    if(typeof v.seconds==='number'){ const d=new Date(v.seconds*1000); return isNaN(d.getTime())? null : d; }
  }
  let s=String(v).trim();
  s=s.replace(/\bat\b/gi,' ').replace(/\s+/g,' ').trim();
  s=s.replace(/UTC\s*([+-]\d{1,2})\b/i,(_m,off)=>'GMT'+off+':00');
  const MONTHS={jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
  let m=/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?(?:\s+GMT([+-]\d{1,2})(?::?(\d{2}))?)?$/i.exec(s);
  if(m){
    const dd=+m[1], mon=(m[2]||'').slice(0,3).toLowerCase(), y=+m[3];
    const hh=m[4]?+m[4]:0, mi=m[5]?+m[5]:0, ss=m[6]?+m[6]:0, mo=MONTHS[mon];
    if(mo!=null){
      let d=new Date(Date.UTC(y,mo,dd,hh,mi,ss));
      if(m[7]){ const offH=+m[7], offM=m[8]?+m[8]:0; const mins=offH*60 + (offH<0?-offM:offM); d=new Date(d.getTime()-mins*60000); }
      return isNaN(d.getTime())? null : d;
    }
  }
  m=/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/.exec(s);
  if(m){ const y=+m[1], mo=+m[2], d=+m[3]; const D=new Date(y,mo-1,d); return (D.getFullYear()===y && D.getMonth()===mo-1 && D.getDate()===d)? D : null; }
  m=/^(\d{1,2})[-\/]((?:0?[1-9]|1[0-2]))[-\/]?(\d{4})$/.exec(s);
  if(m){ const d=+m[1], mo=+m[2], y=+m[3]; const D=new Date(y,mo-1,d); return (D.getFullYear()===y && D.getMonth()===mo-1 && D.getDate()===d)? D : null; }
  const D=new Date(s);
  return isNaN(D.getTime())? null : D;
}
function getEntryDate(e){
  const candidates=[e.timestamp,e.timeStamp,e.ts,e.recordedAt,e.date,e.Date,e.createdAt,e.created,e.created_on,e.id];
  for(const v of candidates){ const d=parseAnyDate(v); if(d) return d; }
  return null;
}

// ===== BBT parse + trim =====
function parseBBT(v){
  if(v==null) return null;
  if(typeof v==='number'){ let n=v; if(n>80) n=(n-32)*5/9; if(n<35.0 || n>38.5) return null; return n; }
  let s=String(v).trim().replace(/[^\d.,\-]/g,'');
  if(s.includes(',') && !s.includes('.')) s=s.replace(',','.');
  let n=parseFloat(s);
  if(!isFinite(n)) return null;
  if(n>80) n=(n-32)*5/9;
  if(n<35.0 || n>38.5) return null;
  return n;
}
function trimOutliers(values){
  if(values.length<5) return values.slice();
  const arr=values.slice().sort((a,b)=>a-b);
  const median=arr[Math.floor(arr.length/2)];
  return values.filter(v=>Math.abs(v-median)<=0.8);
}

// ===== OPK helpers =====
function opkAsNumber(v){
  if(v==null) return null;
  if(typeof v==='number') return v;
  const s=String(v).trim().toLowerCase();
  if(s.includes('surge') || s.includes('solid')) return 1.0;
  if(s.includes('flashing')) return 0.5;
  const n=parseFloat(s);
  return isFinite(n)? n : null;
}
function opkClass(v){
  if(v==null) return 'none';
  const s=(typeof v==='string')? v.toLowerCase() : '';
  const n=opkAsNumber(v);
  if(s.includes('surge') || s.includes('solid') || (n!=null && n>=0.75)) return 'surge';
  if(s.includes('flashing') || (n!=null && n>=0.30 && n<=0.74)) return 'fertile';
  return 'none';
}

// ===== Day1 detection =====
function isDay1(e){
  const ph=(e.phase||'').toLowerCase();
  return ph.includes('day1-period') || ph.includes('day1') || ph.includes('day 1') || ph.includes('day-1') || ph.includes('period start') || e.day1===true;
}

// ===== Firestore load & merge =====
let ENTRIES=[];
const FILTERS={ incAnov:true, bbtOnly:false, lastN:12 };

firebase.auth().onAuthStateChanged(function(u){
  if(!u){ window.location.href='index.html'; return; }

  function normalizeDoc(d){
    const o=d.data(); o.id=d.id; o._src=d.ref.path;
    const dd=getEntryDate(o); o._date=dd; o._key=dd? iso(dd) : null;
    o._bbt=parseBBT(o.bbt);
    return o;
  }

  const top=db.collection('entries').get().then(s=>s.docs.map(normalizeDoc)).catch(()=>[]);
  const user=db.collection('users').doc(u.uid).collection('entries').get().then(s=>s.docs.map(normalizeDoc)).catch(()=>[]);

  Promise.all([top,user]).then(([A,B])=>{
    const merged={};
    for(const e of [...A,...B]){
      if(!e._date) continue;
      const k=e._key;
      if(!merged[k]){ merged[k]=e; continue; }
      const cur=merged[k];
      const curIsD1=isDay1(cur), eIsD1=isDay1(e);
      if(eIsD1 && !curIsD1){ merged[k]=e; continue; }
      if(!eIsD1 && curIsD1){ continue; }
      const curIsUser=String(cur._src||'').includes('/users/');
      const eIsUser=String(e._src||'').includes('/users/');
      if(!curIsUser && eIsUser){ merged[k]=e; continue; }
    }
    ENTRIES=Object.keys(merged).sort().map(k=>merged[k]);
    renderAll();
  }).catch(err=>{
    document.getElementById('cards').innerHTML='<div class="card"><h3>Error</h3><div class="value">No data</div><div class="sub">'+(err&&err.message?err.message:'Query failed')+'</div></div>';
  });
});

// ===== Cycles + assessments =====
function segmentCycles(entries){
  const byDate=entries.filter(e=>e._date instanceof Date && !isNaN(e._date)).sort((a,b)=>a._date - b._date);
  const idxDay1=[]; for(let i=0;i<byDate.length;i++) if(isDay1(byDate[i])) idxDay1.push(i);

  const cycles=[];
  for(let c=0;c<idxDay1.length-1;c++){
    const startIdx=idxDay1[c], nextIdx=idxDay1[c+1];
    const seg=byDate.slice(startIdx, nextIdx);
    const startDate=toUTCmid(byDate[startIdx]._date);
    const nextStart=toUTCmid(byDate[nextIdx]._date);
    const length=dayDiff(startDate,nextStart);
    if(length<2) continue;

    const periodEnd=addDays(startDate,4);

    // Surge & ovulation
    let surgeDate=null, maxNum=-Infinity, maxDate=null;
    for(const e of seg){
      const d=toUTCmid(e._date);
      const cls=opkClass(e.opk);
      if(cls==='surge'){ surgeDate=d; break; }
      const n=opkAsNumber(e.opk); if(n!=null && n>maxNum){ maxNum=n; maxDate=d; }
    }
    if(!surgeDate && maxDate && maxNum>=0.75) surgeDate=maxDate;
    const ovulationDate = surgeDate ? addDays(surgeDate,1) : null;

    // Luteal length
    const lutealLen = (ovulationDate ? dayDiff(ovulationDate, nextStart) : null);

    // BBT stats
    let coverline=null, postOMean=null, risePreToDPO=null, sustainedShift=false, dpoAbove=0;
    if(ovulationDate){
      const preOAll=seg.filter(e=>e._bbt!=null && toUTCmid(e._date) < ovulationDate).slice(-12);
      const preVals=trimOutliers(preOAll.map(e=>e._bbt));
      if(preVals.length>=6){
        const last6=preVals.slice(-6);
        coverline=Math.max(...last6)+0.05;

        const dpoTemps=[];
        for(const e of seg){
          const d=toUTCmid(e._date); const dpo=dayDiff(ovulationDate,d);
          if(dpo>=3 && dpo<=10 && e._bbt!=null){
            dpoTemps.push(e._bbt);
            if(dpo<=6 && e._bbt > coverline + 0.10) dpoAbove++;
          }
        }
        const dpoVals=trimOutliers(dpoTemps);
        if(dpoVals.length>=5) postOMean=dpoVals.reduce((a,b)=>a+b,0)/dpoVals.length;

        const dpo3_6=[];
        for(const e of seg){
          const d=toUTCmid(e._date); const dpo=dayDiff(ovulationDate,d);
          if(dpo>=3 && dpo<=6 && e._bbt!=null) dpo3_6.push(e._bbt);
        }
        const preLast3=preVals.slice(-3);
        if(dpo3_6.length>=3 && preLast3.length===3){
          const mean=arr=>arr.reduce((a,b)=>a+b,0)/arr.length;
          risePreToDPO=mean(dpo3_6)-mean(preLast3);
        }
        sustainedShift = (dpoAbove >= 3);
      }
    }
    if(postOMean!=null && coverline!=null && postOMean < coverline - 0.10) postOMean=null;
    if(risePreToDPO!=null && (risePreToDPO < -0.2 || risePreToDPO > 1.2)) risePreToDPO=null;

    // Sex timing −2..0
    let sexCoverageCount=0; let sexDays=[false,false,false];
    if(ovulationDate){
      for(let i=-2;i<=0;i++){
        const d=addDays(ovulationDate,i);
        const ent=seg.find(e=>iso(toUTCmid(e._date))===iso(d));
        if(ent && String(ent.sex||'').toLowerCase()==='yes'){ sexCoverageCount++; sexDays[i+2]=true; }
      }
    }

    // Flags
    const lpdRisk = (lutealLen!=null && lutealLen<9) || (risePreToDPO!=null && risePreToDPO<0.30);
    const anovSuspect = (!ovulationDate) ||
      ((!sustainedShift) && (!surgeDate || (opkAsNumber(seg.find(e=>iso(toUTCmid(e._date))===iso(surgeDate))?.opk)??0) < 0.75));

    cycles.push({
      entries:seg, startDate, nextStart, length,
      surgeDate, ovulationDate, lutealLen, coverline, postOMean, risePreToDPO, sustainedShift,
      sexCoverageCount, sexDays,
      lpdRisk, anovSuspect
    });
  }
  return cycles;
}

// ===== Metrics =====
function computeMetrics(cycles){
  const completed=cycles.slice();
  const mean=a=>a.length? a.reduce((x,y)=>x+y,0)/a.length : null;
  const sd=a=>{ if(a.length<2) return null; const mu=mean(a); return Math.sqrt(mean(a.map(x=>(x-mu)*(x-mu)))); };

  const lengths=completed.map(c=>c.length);
  const rises=completed.map(c=>c.risePreToDPO).filter(v=>v!=null);

  // Paired coverline/post-O
  const paired=completed.filter(c=>c.coverline!=null && c.postOMean!=null);
  const cover=paired.map(c=>c.coverline);
  const postO=paired.map(c=>c.postOMean);

  // Surge day stats (CD of surge = O-1)
  const surgeCDs = completed.filter(c=>c.surgeDate && c.startDate).map(c=>dayDiff(c.startDate, c.surgeDate)+1);

  function quantiles(arr){
    if(!arr.length) return null;
    const a=arr.slice().sort((x,y)=>x-y);
    const q = p => {
      const idx=(a.length-1)*p;
      const lo=Math.floor(idx), hi=Math.ceil(idx);
      if(lo===hi) return a[lo];
      return a[lo] + (a[hi]-a[lo])*(idx-lo);
    };
    return {median:q(0.5), q1:q(0.25), q3:q(0.75)};
  }

  return {
    N:completed.length,
    cycleLen:{mean:mean(lengths), sd:sd(lengths), N:lengths.length},
    bbtRise:{mean:mean(rises), sd:sd(rises), N:rises.length},
    coverline:{mean:mean(cover), sd:sd(cover), N:cover.length},
    postO:{mean:mean(postO), sd:sd(postO), N:postO.length},
    surge:{ cds: surgeCDs, q: quantiles(surgeCDs) }
  };
}

// ===== Cards =====
function renderCards(m){
  const cards=document.getElementById('cards');
  const f=(x,d)=>x==null?'—':(d===0? Math.round(x) : Number(x).toFixed(d));
  const item=(title,val,sub)=>`<div class="card"><h3>${title}</h3><div class="value">${val}</div><div class="sub">${sub||''}</div></div>`;
  const parts=[];
  parts.push(item('Avg Cycle', `${f(m.cycleLen.mean,1)} d`, `±${f(m.cycleLen.sd,1)} (n=${m.cycleLen.N})`));
  parts.push(item('Coverline (paired)', `${f(m.coverline.mean,2)} °C`, `n=${m.coverline.N}`));
  parts.push(item('Post-O (paired)', `${f(m.postO.mean,2)} °C`, `n=${m.postO.N}`));
  parts.push(item('BBT Rise', `${f(m.bbtRise.mean,2)} °C`, `n=${m.bbtRise.N}`));
  cards.innerHTML=parts.join('');
}

// ===== Ribbons (with sex pills) =====
function renderRibbons(cycles){
  const box=document.getElementById('ribbons'); box.innerHTML='';
  const completed=cycles.slice(-FILTERS.lastN);
  for(let idx=0; idx<completed.length; idx++){
    const c=completed[idx];
    const unit=100/c.length; const bands=[];
    const p0=0, p1=Math.min(5,c.length); bands.push({left:p0*unit, width:(p1-p0)*unit, color:'var(--red)'});
    if(c.surgeDate){ const s=dayDiff(c.startDate,c.surgeDate); bands.push({left:s*unit, width:Math.max(1.5,unit*0.9), color:'var(--purple)'}); }
    if(c.ovulationDate){ const o=dayDiff(c.startDate,c.ovulationDate); bands.push({left:o*unit, width:Math.max(1.5,unit*0.9), color:'var(--blue)'}); }
    if(c.ovulationDate){ const o2=dayDiff(c.startDate,c.ovulationDate)+1; bands.push({left:o2*unit, width:(c.length-o2)*unit, color:'var(--green)'}); }
    const bandHTML=bands.map(b=>`<div class="band" style="left:${b.left}%;width:${b.width}%;background:${b.color}"></div>`).join('');
    const label=`${iso(c.startDate)} → ${iso(addDays(c.nextStart,-1))} · ${c.length}d`;
    const flags = [ c.lpdRisk ? 'LPD risk' : null, c.anovSuspect ? 'Anovulation?' : null ].filter(Boolean).join(' · ');
    const right = flags || (c.ovulationDate?(`O: CD ${dayDiff(c.startDate,c.ovulationDate)+1}`):'No O detected');
    const pills = c.ovulationDate
      ? `<div class="pills" title="Target −2, −1, 0">
           <div class="pill ${c.sexDays[0]?'on':''}"></div>
           <div class="pill ${c.sexDays[1]?'on':''}"></div>
           <div class="pill ${c.sexDays[2]?'on':''}"></div>
         </div>` : '';
    const div=document.createElement('div'); div.className='ribbon';
    div.innerHTML=`<div class="label"><span>${label}</span><span>${right}</span></div><div class="bar">${bandHTML}</div>${pills}`;
    box.appendChild(div);
  }
}

// ===== Insights (no bars) =====
function renderInsights(cycles, m){
  const last = cycles.slice(-FILTERS.lastN);

  // --- LH Surge strip ---
  const surgeStats = document.getElementById('surgeStats');
  const surgeNotes = document.getElementById('surgeNotes');
  surgeNotes.innerHTML='';
  if(m.surge.q){
    const {median,q1,q3}=m.surge.q;
    surgeStats.textContent = `Median CD ${Math.round(median)} • IQR ${Math.round(q1)}–${Math.round(q3)} (n=${m.surge.cds.length})`;
  } else {
    surgeStats.textContent = 'No surge entries available';
  }
  drawSurgeStrip(last);

  // Notes for cycles without surge
  last.forEach((c,i)=>{
    if(!c.surgeDate){
      const span=document.createElement('div');
      const label=`C${i+1}`;
      span.innerHTML = `<span class="chip">${label}</span> no surge ≥0.75/“Surge”`;
      surgeNotes.appendChild(span);
    }
  });

  // --- BBT rise list ---
  const riseStats = document.getElementById('riseStats');
  const rises = last.map(c=>c.risePreToDPO).filter(v=>v!=null);
  const pctGood = rises.length? Math.round(100*rises.filter(v=>v>=0.30).length/rises.length) : null;
  riseStats.textContent = rises.length ? `Avg Δ ${rises.reduce((a,b)=>a+b,0)/rises.length >=0 ? (rises.reduce((a,b)=>a+b,0)/rises.length).toFixed(2):'—'} °C • ${pctGood}% ≥ 0.30 °C (n=${rises.length})` : 'No BBT rise data';
  const riseList = document.getElementById('riseList'); riseList.innerHTML='';
  last.forEach((c,i)=>{
    const id=`C${i+1}`;
    if(c.coverline!=null && c.postOMean!=null && c.risePreToDPO!=null){
      const div=document.createElement('div');
      div.textContent = `${id} — ${c.coverline.toFixed(2)} → ${c.postOMean.toFixed(2)} (Δ +${c.risePreToDPO.toFixed(2)} °C)`;
      riseList.appendChild(div);
    }
  });

  // --- LPD summary + reasons + matrix ---
  const lpdBig=document.getElementById('lpdBig');
  const lpdSmall=document.getElementById('lpdSmall');
  const lpdReasons=document.getElementById('lpdReasons'); lpdReasons.innerHTML='';
  const lpdRows=[['Cycle','Luteal<9','Rise<0.30']];
  let lpdCount=0;
  last.forEach((c,i)=>{
    if(c.lpdRisk) lpdCount++;
    const row=[`C${i+1}`, c.lutealLen!=null && c.lutealLen<9 ? '✓' : '✗', c.risePreToDPO!=null && c.risePreToDPO<0.30 ? '✓' : '✗'];
    lpdRows.push(row);
    if(c.lpdRisk){
      const parts=[];
      if(c.lutealLen!=null && c.lutealLen<9) parts.push(`luteal ${c.lutealLen}d`);
      if(c.risePreToDPO!=null && c.risePreToDPO<0.30) parts.push(`rise ${c.risePreToDPO.toFixed(2)}°C`);
      const div=document.createElement('div');
      div.innerHTML=`<span class="chip">C${i+1}</span> ${parts.join(' · ')}`;
      lpdReasons.appendChild(div);
    }
  });
  lpdBig.textContent = `${lpdCount}/${last.length}`;
  lpdSmall.textContent = 'cycles flagged';
  renderMatrix('lpdMatrix', lpdRows);

  // --- Anov summary + reasons + matrix ---
  const anovBig=document.getElementById('anovBig');
  const anovSmall=document.getElementById('anovSmall');
  const anovReasons=document.getElementById('anovReasons'); anovReasons.innerHTML='';
  const anovRows=[['Cycle','No surge','No sustained shift']];
  let anovCount=0;
  last.forEach((c,i)=>{
    const noSurge = !c.surgeDate;
    const noShift = !c.sustainedShift;
    if(c.anovSuspect) anovCount++;
    anovRows.push([`C${i+1}`, noSurge?'✓':'✗', noShift?'✓':'✗']);
    if(c.anovSuspect){
      const parts=[];
      if(noSurge) parts.push('no surge ≥0.75/“Surge”');
      if(noShift) parts.push('<3 temps above CL+0.10 (DPO3–6)');
      if(!c.ovulationDate) parts.push('no ovulation inferred');
      const div=document.createElement('div');
      div.innerHTML=`<span class="chip">C${i+1}</span> ${parts.join(' · ')}`;
      anovReasons.appendChild(div);
    }
  });
  anovBig.textContent = `${anovCount}/${last.length}`;
  anovSmall.textContent = 'cycles flagged';
  renderMatrix('anovMatrix', anovRows);

  // --- Sex timing summary + pills ---
  const full3 = last.filter(c=>c.sexCoverageCount===3).length;
  const b0 = last.filter(c=>c.sexCoverageCount===0).length;
  const b1 = last.filter(c=>c.sexCoverageCount===1).length;
  const b2 = last.filter(c=>c.sexCoverageCount===2).length;
  const b3 = last.filter(c=>c.sexCoverageCount===3).length;
  document.getElementById('sexStats').textContent = `Target days −2, −1, 0 (3/3 = 100%)`;
  document.getElementById('sexBreak').textContent = `0/3:${b0} • 1/3:${b1} • 2/3:${b2} • 3/3:${b3} • 100% hits: ${full3}/${last.length}`;
  const sexPills=document.getElementById('sexPills'); sexPills.innerHTML='';
  last.forEach((c,i)=>{
    const row=document.createElement('div');
    row.innerHTML = `<span class="chip">C${i+1}</span>
      <span class="pill ${c.sexDays[0]?'on':''}"></span>
      <span class="pill ${c.sexDays[1]?'on':''}"></span>
      <span class="pill ${c.sexDays[2]?'on':''}"></span>`;
    sexPills.appendChild(row);
  });
}

// Draw LH surge strip (dot strip with CD axis)
function drawSurgeStrip(cycles){
  const canvas=document.getElementById('surgeCanvas');
  const dpr=window.devicePixelRatio||1;
  const cssW=canvas.clientWidth, cssH=canvas.clientHeight;
  canvas.width=cssW*dpr; canvas.height=cssH*dpr;
  const ctx=canvas.getContext('2d'); ctx.scale(dpr,dpr);
  ctx.clearRect(0,0,cssW,cssH);

  // Determine CD range from data (default 8..20)
  const cds = cycles.map(c=>c.surgeDate && c.startDate ? (dayDiff(c.startDate,c.surgeDate)+1) : null).filter(v=>v!=null);
  let minCD = cds.length? Math.min.apply(null, cds) : 8;
  let maxCD = cds.length? Math.max.apply(null, cds) : 20;
  minCD=Math.max(6, Math.min(minCD, 12));
  maxCD=Math.min(28, Math.max(maxCD, 16));
  const left=32, right=cssW-12, top=18, y=cssH/2;

  // Axis
  ctx.strokeStyle="#ddd"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke();
  // ticks
  const tickEvery = 2;
  for(let cd=minCD; cd<=maxCD; cd+=tickEvery){
    const x = left + (cd-minCD)/(maxCD-minCD || 1) * (right-left);
    ctx.beginPath(); ctx.moveTo(x, y-6); ctx.lineTo(x, y+6); ctx.stroke();
    ctx.fillStyle="#888"; ctx.font="11px system-ui"; ctx.textAlign="center"; ctx.fillText(String(cd), x, top-4);
  }

  // Dots: filled = real surge, hollow = no surge (if O inferred)
  let row=0; const rows=3; // slight vertical jitter to avoid overlap
  cycles.forEach(c=>{
    const cdSurge = (c.surgeDate && c.startDate) ? (dayDiff(c.startDate,c.surgeDate)+1) : null;
    const cdO = (c.ovulationDate && c.startDate) ? (dayDiff(c.startDate,c.ovulationDate)+1) : null;
    const cd = cdSurge!=null ? cdSurge : (cdO!=null ? cdO-1 : null);
    if(cd==null) return;
    const x = left + (cd-minCD)/(maxCD-minCD || 1) * (right-left);
    const yy = y + ((row%rows)-1)*10; row++;
    ctx.beginPath(); ctx.arc(x, yy, 4, 0, Math.PI*2);
    if(cdSurge!=null){ ctx.fillStyle="rgba(209,95,167,0.9)"; ctx.fill(); }
    else { ctx.strokeStyle="rgba(209,95,167,0.9)"; ctx.lineWidth=2; ctx.stroke(); }
  });
}

// Matrix builder
function renderMatrix(id, rows){
  const tbl=document.getElementById(id);
  let html='';
  rows.forEach((r,ri)=>{
    if(ri===0){
      html += '<tr>'+r.map(c=>`<th>${c}</th>`).join('')+'</tr>';
    } else {
      html += '<tr>'+r.map((c,ci)=>{
        if(ci===0) return `<td style="text-align:left">${c}</td>`;
        return `<td class="${c==='✓'?'ok':'no'}">${c}</td>`;
      }).join('')+'</tr>';
    }
  });
  tbl.innerHTML=html;
}

// ===== Orchestration =====
function renderAll(){
  if(!ENTRIES.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>No data</h3><div class="value">—</div><div class="sub">No entries in Firestore</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  const cycles=segmentCycles(ENTRIES);
  if(!cycles.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>Setup</h3><div class="value">0 cycles</div><div class="sub">No completed cycles detected. Ensure each cycle has a Day 1 and the next Day 1.</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  const m=computeMetrics(cycles);
  renderCards(m);
  renderRibbons(cycles);
  renderInsights(cycles, m);
}

// Sheet controls
const sheet=document.getElementById('sheet');
document.getElementById('filterBtn').addEventListener('click',()=>sheet.classList.add('open'));
sheet.addEventListener('click',e=>{ if(e.target===sheet) sheet.classList.remove('open'); });
document.getElementById('applyFilters').addEventListener('click',()=>{
  FILTERS.incAnov=document.getElementById('incAnov').checked;
  FILTERS.bbtOnly=document.getElementById('bbtOnly').checked;
  FILTERS.lastN=Math.max(1, Math.min(36, Number(document.getElementById('lastN').value||12)));
  sheet.classList.remove('open');
  renderAll();
});
document.getElementById('exportBtn').addEventListener('click',()=>window.print());
</script>
</body>
</html>
