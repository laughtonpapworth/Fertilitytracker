<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>History</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="js/firebase-config.js"></script>

<style>
:root{
  --bg:#fffafc; --ink:#222; --muted:#6b6b6b; --card:#ffffff; --brand:#88a58d;
  --red:#f28b82; --green:#a5d6a7; --blue:#8ab4f8; --amber:#fbc02d; --purple:#d15fa7;
  --line:#e9ecef; --chip:#f1f3f4;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font-family:"Segoe UI",system-ui,-apple-system,sans-serif}
header{position:sticky;top:0;background:var(--bg);z-index:10;padding:12px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;gap:8px}
header h1{font-size:18px;margin:0;font-weight:600}
header .spacer{flex:1}
header button{border:none;background:var(--brand);color:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
header .ghost{background:#e9efe9;color:#2f4733}

.cards{display:flex;gap:10px;overflow:auto;padding:12px 12px 4px}
.card{min-width:160px;background:var(--card);border:1px solid #eee;border-radius:14px;padding:10px;box-shadow:0 2px 6px rgba(0,0,0,.04)}
.card h3{font-size:12px;color:var(--muted);margin:0 0 6px}
.card .value{font-size:22px;font-weight:700}
.card .sub{font-size:12px;color:var(--muted)}

.section{padding:8px 12px}
.section h2{font-size:16px;margin:8px 0}

.ribbons{display:flex;flex-direction:column;gap:10px}
.ribbon{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px}
.ribbon .label{font-weight:600;font-size:13px;margin-bottom:6px;display:flex;justify-content:space-between;color:var(--muted)}
.bar{position:relative;height:10px;background:#f3f3f3;border-radius:999px;overflow:hidden}
.band{position:absolute;top:0;bottom:0;border-radius:999px}
.legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted)}
.swatch{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:4px;vertical-align:middle}

.grid{display:grid;grid-template-columns:1fr;gap:12px;padding:8px 12px}
@media(min-width:560px){.grid{grid-template-columns:1fr 1fr}}

.panel{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px}
.panel h3{font-size:14px;margin:0 0 4px}
.panel .caption{font-size:12px;color:var(--muted);margin-bottom:8px}
.reasons{font-size:12px;color:var(--ink);display:flex;flex-direction:column;gap:4px;margin-top:6px}
.chip{display:inline-block;background:var(--chip);border:1px solid #e2e6ea;border-radius:999px;padding:2px 8px;margin-right:6px;font-size:12px}
.line{font-size:12px}

/* BBT rise bars / dots */
.riseRow{display:flex;align-items:center;gap:8px;padding:6px 8px;border:1px solid var(--line);border-radius:10px}
.delta{font-size:12px;font-weight:700;padding:2px 8px;border-radius:999px}
.delta.good{background:rgba(165,214,167,.25);border:1px solid #a5d6a7}
.delta.warn{background:rgba(242,139,130,.25);border:1px solid #f28b82}

/* Matrices */
.matrix{width:100%;border-collapse:collapse;font-size:12px;margin-top:6px}
.matrix th,.matrix td{border:1px solid #eee;padding:6px;text-align:center}
.matrix th{background:#fafafa;font-weight:600;color:var(--muted)}
.ok{color:#2e7d32;font-weight:700}
.no{color:#c62828;font-weight:700}

/* Surge strip */
#surgeCanvas{width:100%;height:90px;border:1px solid #eee;border-radius:8px;background:#fff}

/* Sex timing row */
.pillRow{display:flex;align-items:center;gap:8px}
.pillLbl{width:28px;font-size:11px;color:var(--muted);text-align:right}
.dot{width:14px;height:14px;border-radius:50%;border:2px solid #cbd5e1;background:#fff}
.dot.on{background:var(--blue);border-color:var(--blue)}
.dot.opt{opacity:.45}

/* Post-ovulation BBT dots */
.bbtBar{display:flex;gap:4px;align-items:center;min-height:16px;flex-wrap:wrap}
.bbtDot{width:14px;height:14px;border-radius:3px;border:1px solid #cbd5e1;background:#111}
.bbtDot.red{background:var(--red);}      /* +0.10..+0.19 */
.bbtDot.green{background:var(--green);}  /* ≥ +0.20 */
.bbtDot.base{background:#111;}           /* ≤ +0.09 */
</style>
</head>
<body>
<header>
  <button class="ghost" id="homeBtn">Home</button>
  <h1>History</h1>
  <div class="spacer"></div>
  <button id="shareBtn">Share</button>
</header>

<div class="cards" id="cards"></div>

<div class="section">
  <h2>Completed Cycles</h2>
  <div class="ribbons" id="ribbons"></div>
  <div class="legend">
    <span><span class="swatch" style="background:var(--red)"></span>Period</span>
    <span><span class="swatch" style="background:var(--amber)"></span>Fertile</span>
    <span><span class="swatch" style="background:var(--purple)"></span>Surge</span>
    <span><span class="swatch" style="background:var(--blue)"></span>Ovulation</span>
    <span><span class="swatch" style="background:var(--green)"></span>Luteal</span>
  </div>
</div>

<div class="section"><h2>Insights & Trends</h2></div>
<div class="grid">
  <div class="panel">
    <h3>LH surge day (CD)</h3>
    <div class="caption" id="surgeStats">—</div>
    <canvas id="surgeCanvas"></canvas>
    <div id="surgeNotes" class="reasons"></div>
  </div>

  <div class="panel">
    <h3>BBT rise per cycle</h3>
    <div class="caption">Post-ovulation daily temps vs coverline through full luteal: <b style="color:var(--green)">Green</b> ≥ +0.20 °C, <b style="color:var(--red)">Red</b> = +0.10…+0.19 °C, <b>Black</b> ≤ +0.09 °C.</div>
    <div class="caption" id="riseStats">—</div>
    <div id="riseList" class="reasons"></div>
  </div>

  <div class="panel">
    <h3>LPD risk (low progesterone)</h3>
    <table class="matrix" id="lpdMatrix"></table>
  </div>

  <div class="panel">
    <h3>Anovulation suspect</h3>
    <table class="matrix" id="anovMatrix"></table>
  </div>

  <div class="panel">
    <h3>Sex timing — ideal vs met</h3>
    <div class="caption" id="sexStats">Ideal −2, −1, 0 (+1 optional). Filled = met.</div>
    <div id="sexBreak" class="line"></div>
    <div id="sexPills" class="reasons"></div>
  </div>
</div>

<script>
console.log('[history] build 2025-08-14 v11: flags back on BBT rise rows, whole-number banner, simplified pills, no filters, share report');

/* ---------- Config ---------- */
const LAST_N = 12; // show last N completed cycles

/* ---------- Date helpers ---------- */
function toUTCmid(d){ return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); }
function addDays(d,n){ const x=new Date(d.getTime()); x.setDate(x.getDate()+n); return x; }
function dayDiff(a,b){ if(!(a instanceof Date)||!(b instanceof Date)) return 0; const A=toUTCmid(a), B=toUTCmid(b); return Math.max(0, Math.floor((B-A)/86400000)); }
function iso(d){ return (d instanceof Date && !isNaN(d.getTime())) ? d.toISOString().slice(0,10) : '—'; }
function monthShort(d){ return d.toLocaleString('en-US',{month:'short'}); }
function cycleMonthSpan(c){
  const start=c.startDate, end=addDays(c.nextStart,-1);
  const ms=monthShort(start), me=monthShort(end);
  const ys=start.getFullYear(), ye=end.getFullYear();
  return ys===ye ? `${ms}–${me}` : `${ms} ${ys}–${me} ${ye}`;
}

/* ---------- Parse entry DATE ---------- */
function stripAtTail(s){ const i=s.indexOf(' at '); return i>=0? s.slice(0,i) : s; }
function parseAnyDate(v){
  if(v==null) return null;
  if(v instanceof Date) return isNaN(v.getTime())? null : v;
  if(typeof v==='number'){ const d=new Date(v); return isNaN(d.getTime())? null : d; }
  let s=String(v).trim(); s=stripAtTail(s);
  let m=/^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s); if(m){ const D=new Date(+m[1],+m[2]-1,+m[3]); return isNaN(D)?null:D; }
  m=/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})$/.exec(s);
  if(m){ const MONTHS={jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11}; const D=new Date(+m[3],MONTHS[m[2].slice(0,3).toLowerCase()],+m[1]); return isNaN(D)?null:D; }
  const D=new Date(s); return isNaN(D)? null : D;
}
function getEntryDate(e){
  const fields=[e.entryDate, e['entry-date'], e.entry_date, e.date, e.Date];
  for(const v of fields){ const d=parseAnyDate(v); if(d) return d; }
  if (typeof e.id === 'string') {
    const m=/^(\d{4})-(\d{2})-(\d{2})$/.exec(e.id);
    if (m) { const D=new Date(+m[1],+m[2]-1,+m[3]); if(!isNaN(D)) return D; }
  }
  return null;
}

/* ---------- BBT parsing ---------- */
function parseBBT(v){
  if(v==null) return null;
  if(typeof v==='number'){ let n=v; if(n>80) n=(n-32)*5/9; if(n<35||n>38.5) return null; return n; }
  let s=String(v).trim().replace(/[^\d.,\-]/g,''); if(s.includes(',')&&!s.includes('.')) s=s.replace(',','.');
  let n=parseFloat(s); if(!isFinite(n)) return null; if(n>80) n=(n-32)*5/9; if(n<35||n>38.5) return null; return n;
}

/* ---------- OPK helpers ---------- */
function opkAsNumber(v){
  if (v == null) return null;
  if (typeof v === 'number') return v;
  let s = String(v).trim().toLowerCase();
  s = s.replace(/[%]/g,'').replace(',', '.');
  if (/\b(surge|solid|peak|static)\b/.test(s)) return 1.0;        // labels used only for visuals
  if (/\b(flash|flashing|high|smiley)\b/.test(s)) return 0.5;
  const n = parseFloat(s); return isFinite(n)? n : null;
}
function isLabeledSurge(v){ if(v==null) return false; return /\b(surge|solid|peak|static)\b/i.test(String(v)); }
function isLabeledFertile(v){ if(v==null) return false; return /\b(flash|flashing|high|smiley)\b/i.test(String(v)); }
function opkClass(v){
  if (v == null) return 'none';
  const n = opkAsNumber(v);
  if (isLabeledSurge(v) || (n!=null && n>=0.75)) return 'surge';
  if (isLabeledFertile(v) || (n!=null && n>=0.30 && n<=0.74)) return 'fertile';
  return 'none';
}
function cmScore(cm){
  if(!cm) return 0; const s=String(cm).toLowerCase();
  if(s.includes('egg')) return 4; if(s.includes('watery')) return 3; if(s.includes('creamy')) return 2; if(s.includes('sticky')) return 1;
  return 0;
}

/* ---------- Day1 detector ---------- */
function isDay1(e){
  const ph=(e.phase||'').toLowerCase().replace(/[^a-z0-9]/g,'');
  return ph==='day1period' || ph==='periodstart' || e.day1===true;
}

/* ---------- Firestore load, per-field merge, per-day compress ---------- */
let ENTRIES=[];
firebase.auth().onAuthStateChanged(async function(u){
  if(!u){ window.location.href='index.html'; return; }

  function normalizeDoc(d){
    const o=d.data(); o.id=d.id; o._src=d.ref.path;
    o._date = getEntryDate(o);
    o._key  = o._date? iso(o._date) : null;
    o._bbt  = parseBBT(o.bbt);
    o._raw = {
      entryDate: o.entryDate ?? o['entry-date'] ?? o.entry_date ?? o.date ?? o.Date ?? null,
      timestamp: o.timestamp ?? o.Timestamp ?? null,
      opk: o.opk ?? null
    };
    return o;
  }

  const db = firebase.firestore();

  const guesses = [];
  if (u && u.uid) guesses.push(u.uid);
  if (u && u.displayName) guesses.push(u.displayName);
  if (u && u.email) { const local = String(u.email).split('@')[0]; if (local && !guesses.includes(local)) guesses.push(local); }

  const queries = [];
  queries.push(db.collection('entries').get().then(s=>s.docs.map(normalizeDoc)).catch(()=>[])); // top-level
  for (const key of guesses) {
    queries.push(
      db.collection('users').doc(key).collection('entries').get()
        .then(s=>s.docs.map(normalizeDoc))
        .catch(()=>[])
    );
  }

  try{
    const results = await Promise.all(queries);
    const all = results.flat();

    const buckets = {};
    for (const e of all) {
      if (!e._key) continue;
      (buckets[e._key] ||= []).push(e);
    }

    const daily=[];
    const keys=Object.keys(buckets).sort();
    for(const k of keys){
      const arr=buckets[k];

      const userFirst = arr.find(x=>String(x._src||'').includes('/users/')) || arr[0];
      const base = { id:userFirst.id, _src:userFirst._src, _date:userFirst._date, _key:k };

      // BBT
      let bbt=null;
      for(const e of arr){ if(String(e._src||'').includes('/users/') && e._bbt!=null) { bbt=e._bbt; break; } }
      if(bbt==null){ for(const e of arr){ if(e._bbt!=null){ bbt=e._bbt; break; } } }
      base._bbt = bbt; base.bbt = bbt;

      // OPK precedence (per day)
      let hasLabelSurge=false, hasLabelFertile=false, maxNum=null;
      for(const e of arr){
        if(isLabeledSurge(e.opk)) hasLabelSurge=true;
        if(isLabeledFertile(e.opk)) hasLabelFertile=true;
        const n=opkAsNumber(e.opk);
        if(n!=null) maxNum = (maxNum==null? n : Math.max(maxNum, n));
      }
      if (hasLabelSurge || (maxNum!=null && maxNum>=0.75)) base.opk = 'Surge';
      else if (hasLabelFertile || (maxNum!=null && maxNum>=0.30 && maxNum<=0.74)) base.opk = 'Flashing';
      else base.opk = '';
      base._opkNum = (maxNum!=null? maxNum : (hasLabelSurge? 1.0 : null));

      base.sex = arr.some(e=>String(e.sex||'').toLowerCase()==='yes') ? 'yes' : '';

      let bestCM=null, bestScore=-1;
      for(const e of arr){ const sc=cmScore(e.cm); if(sc>bestScore){ bestScore=sc; bestCM=e.cm; } }
      base.cm = bestCM;

      base.day1 = arr.some(e=>isDay1(e));
      base.phase = base.day1 ? 'day1-period' : (arr.find(e=>e.phase)?.phase || '');

      const hasSymptoms = arr.some(e=>{
        if (e.symptoms && String(e.symptoms).trim()!=='') return true;
        if (Array.isArray(e.symptomList) && e.symptomList.length>0) return true;
        return false;
      });
      base._hasSymptoms = hasSymptoms;

      daily.push(base);
    }

    ENTRIES=daily;
    renderAll();
  }catch(err){
    document.getElementById('cards').innerHTML='<div class="card"><h3>Error</h3><div class="value">—</div><div class="sub">'+(err&&err.message?err.message:'Query failed')+'</div></div>';
  }
});

/* --- BBT shift & coverline --- */
function detectBbtShiftAndCoverline(segSorted, offsetC = 0.05) {
  const days = segSorted
    .filter(e => e._bbt != null)
    .map(e => ({ d: toUTCmid(e._date), t: e._bbt }))
    .sort((a,b)=> a.d - b.d);

  if (days.length < 10) return null;

  const T = days.map(x => x.t);

  for (let i = 6; i + 3 < T.length; i++) {
    const pre6      = T.slice(i-6, i);
    const pre6max   = Math.max.apply(null, pre6);
    const coverline = pre6max + offsetC;

    const next4 = [T[i], T[i+1], T[i+2], T[i+3]];
    const hits  = next4.filter(v => v >= coverline - 1e-6).length;

    if (hits >= 3) {
      const shiftIndex = i;
      const shiftDate  = days[shiftIndex].d;
      const ovDate     = addDays(shiftDate, -1);

      const postODeltas = days
        .map(x => ({ dpo: dayDiff(ovDate, x.d), temp: x.t }))
        .filter(x => x.dpo >= 1)
        .map(x => ({ ...x, delta: x.temp - coverline }));

      return {
        shiftIndex, shiftDate, ovDate, coverline,
        pre6max, pre6Window: days.slice(i-6, i).map(x => ({ date: iso(x.d), t: x.t })),
        postODeltas,
        method: `BBT shift: max of previous 6 + ${offsetC.toFixed(2)}°C`
      };
    }
  }
  return null;
}

/* ---------- Cycle building & metrics ---------- */
function buildCycle(seg, startDate, nextStart) {
  const segSorted = seg.slice().sort((a,b) => a._date - b._date);

  // Map OPK per day
  const S = segSorted.map(e => {
    const nRaw  = (e._opkNum != null ? e._opkNum : opkAsNumber(e.opk));
    const label = isLabeledSurge(e.opk);
    const cls   = (label || (nRaw != null && nRaw >= 0.75)) ? 'surge'
                 : (isLabeledFertile(e.opk) || (nRaw != null && nRaw >= 0.30 && nRaw <= 0.74)) ? 'fertile'
                 : 'none';
    const nEff  = (nRaw != null ? nRaw : (label ? 1.0 : null));
    return { e, d: toUTCmid(e._date), nRaw, nEff, label, cls };
  });

  // Numeric-only surge evidence
  let lhNumSurgePresent = false;
  let surgeNumDate = null;
  for (const x of S) {
    if (typeof x.nRaw === 'number' && x.nRaw >= 0.75) {
      lhNumSurgePresent = true;
      if (!surgeNumDate) surgeNumDate = x.d;
    }
  }

  // Runs for visuals (labels allowed)
  let surgeDate = null;
  let runs = [], cur = null;
  S.forEach((x,i) => {
    if (x.cls === 'surge') {
      if (!cur) cur = { start:i, end:i, peakI:i, peakV:(x.nEff ?? -Infinity) };
      else { cur.end = i; if ((x.nEff ?? -Infinity) > cur.peakV) { cur.peakV = x.nEff; cur.peakI = i; } }
    } else { if (cur) { runs.push(cur); cur = null; } }
  });
  if (cur) runs.push(cur);
  if (runs.length) {
    let best = runs[0];
    for (const r of runs) {
      if (r.peakV > best.peakV) best = r;
      else if (r.peakV === best.peakV && S[r.peakI].d < S[best.peakI].d) best = r;
    }
    surgeDate = S[best.peakI].d;
  }

  // Anchor ovulation to numeric surge when present
  const surgeAnchor = surgeNumDate || surgeDate; // for strict numeric-only everywhere, use: const surgeAnchor = surgeNumDate || null;
  const ovulationDate = surgeAnchor ? addDays(surgeAnchor, 1) : null;
  const surgeCD = surgeAnchor ? (dayDiff(startDate, surgeAnchor) + 1) : null;

  // Fertile window
  const periodEnd = addDays(startDate, 4);
  let fertileStart = null, fertileEnd = null;
  if (ovulationDate){
    const lastPreO = addDays(ovulationDate,-1);
    for (const e of segSorted){
      const d = toUTCmid(e._date);
      if (d <= periodEnd) continue;
      if (d > lastPreO) break;
      if (opkClass(e.opk)==='fertile' || (e._opkNum!=null && e._opkNum>=0.30 && e._opkNum<=0.74)){
        if(!fertileStart) fertileStart = d;
        fertileEnd = d;
      }
    }
    if (!fertileStart) fertileStart = addDays(ovulationDate,-5);
    if (!fertileEnd)   fertileEnd   = lastPreO;
    if (fertileStart && fertileStart <= periodEnd) fertileStart = addDays(periodEnd,1);
  }

  // Luteal length
  const lutealLen = (ovulationDate ? dayDiff(ovulationDate, nextStart) : null);

  // BBT coverline & deltas
  let coverline = null, postOMean = null, risePreToDPO = null;
  let _postODeltas = [];
  let _clMeta = null;

  const bbtShift = detectBbtShiftAndCoverline(segSorted, 0.05);
  if (bbtShift) {
    coverline    = bbtShift.coverline;
    _postODeltas = bbtShift.postODeltas;
    _clMeta = {
      method: bbtShift.method,
      windowTemps: bbtShift.pre6Window,
      baseMax: bbtShift.pre6max,
      coverline
    };

    const dpo3_6 = _postODeltas.filter(x => x.dpo >= 3 && x.dpo <= 6).map(x => x.temp);
    if (dpo3_6.length >= 3) {
      const avg = a => a.reduce((s,v) => s + v, 0) / a.length;
      postOMean = avg(dpo3_6);
      risePreToDPO = postOMean - coverline;
    }
  }

  // Progesterone metrics (0.20°C rule)
  let pScore = null, pScoreDen = null, hasMultiDayDrop = null, sustainedShiftProg = null;
  if (_postODeltas.length) {
    const del = _postODeltas.filter(x => x.dpo >= 1 && x.dpo <= 10).sort((a,b) => a.dpo - b.dpo);
    pScoreDen = del.length;
    pScore    = del.filter(x => x.delta >= 0.20 - 1e-6).length;

    hasMultiDayDrop = del.some((x,i) => i>0 && del[i-1].delta < 0.20 - 1e-6 && x.delta < 0.20 - 1e-6);

    sustainedShiftProg = del.some((_,i) => {
      const slab = del.slice(i, i+4);
      return slab.length===4 && slab.filter(y => y.delta >= 0.20 - 1e-6).length >= 3;
    });
  }

  const lpdFromBBT = (pScoreDen!=null && pScoreDen>=6) ? ((pScore<6) || !!hasMultiDayDrop) : null;
  const lpdRisk = (lutealLen!=null && lutealLen<9) || (lpdFromBBT===true);

  const anovSuspect = !(lhNumSurgePresent && sustainedShiftProg===true);

  // Sex timing
  const sexCoverageCount = (()=>{ 
    if (!ovulationDate) return 0;
    const map = new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit = d => { const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    const arr=[ hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate) ];
    return arr.filter(Boolean).length;
  })();

  const sexDays = (()=>{ 
    if (!ovulationDate) return [false,false,false];
    const map=new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit=d=>{ const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    return [hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate)];
  })();

  const sexDays4 = (()=>{ 
    if (!ovulationDate) return [false,false,false,false];
    const map=new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit=d=>{ const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    return [hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate), hit(addDays(ovulationDate,1))];
  })();

  return {
    entries: seg,
    startDate, nextStart,
    length: dayDiff(startDate, nextStart),
    surgeDate, surgeCD,
    ovulationDate, lutealLen,
    fertileStart, fertileEnd,
    coverline, postOMean, risePreToDPO,
    clMeta: _clMeta,
    postODeltas: _postODeltas,
    pScore, pScoreDen, hasMultiDayDrop, sustainedShiftProg,
    lhNumSurgePresent, surgeNumDate,
    lpdRisk, anovSuspect,
    sexCoverageCount, sexDays, sexDays4
  };
}

function segmentCycles(entries){
  const byDate=entries.filter(e=>e._date instanceof Date && !isNaN(e._date)).sort((a,b)=>a._date - b._date);
  const idxDay1=[]; for(let i=0;i<byDate.length;i++) if(isDay1(byDate[i])) idxDay1.push(i);

  const cycles=[];

  if (idxDay1.length && idxDay1[0] > 0) {
    const startIdx = 0, nextIdx = idxDay1[0];
    const seg = byDate.slice(startIdx, nextIdx);
    const startDate = toUTCmid(byDate[startIdx]._date);
    const nextStart = toUTCmid(byDate[nextIdx]._date);
    if (dayDiff(startDate, nextStart) >= 2) cycles.push(buildCycle(seg, startDate, nextStart));
  }

  for(let c=0;c<idxDay1.length-1;c++){
    const startIdx=idxDay1[c], nextIdx=idxDay1[c+1];
    const seg=byDate.slice(startIdx, nextIdx);
    const startDate=toUTCmid(byDate[startIdx]._date);
    const nextStart=toUTCmid(byDate[nextIdx]._date);
    if(dayDiff(startDate,nextStart) >= 2) cycles.push(buildCycle(seg, startDate, nextStart));
  }
  return cycles;
}

/* ---------- Metrics & UI ---------- */
function computeMetrics(cycles){
  const mean=a=>a.length? a.reduce((x,y)=>x+y,0)/a.length : null;
  const sd=a=>{ if(a.length<2) return null; const mu=mean(a); return Math.sqrt(mean(a.map(x=>(x-mu)*(x-mu)))); };

  const lengths=cycles.map(c=>c.length);
  const luteals=cycles.map(c=>c.lutealLen).filter(v=>v!=null);
  const ovDays=cycles.filter(c=>c.ovulationDate).map(c=>dayDiff(c.startDate,c.ovulationDate)+1);
  const fertOffsets = cycles.filter(c=>c.fertileStart).map(c=>dayDiff(addDays(c.startDate,4), c.fertileStart));
  const fertLengths = cycles.filter(c=>c.fertileStart && c.fertileEnd).map(c=>dayDiff(c.fertileStart, c.fertileEnd)+1);

  const paired=cycles.filter(c=>c.coverline!=null && c.postOMean!=null);
  const cover=paired.map(c=>c.coverline);
  const postO=paired.map(c=>c.postOMean);

  const surgeCDs = cycles.map(c=>c.surgeCD).filter(v=>v!=null);
  function quantiles(arr){ if(!arr.length) return null; const a=arr.slice().sort((x,y)=>x-y);
    const q=p=>{ const i=(a.length-1)*p, lo=Math.floor(i), hi=Math.ceil(i); return lo===hi?a[lo]:a[lo]+(a[hi]-a[lo])*(i-lo); };
    return {median:q(0.5), q1:q(0.25), q3:q(0.75)}; }

  return {
    N:cycles.length,
    cycleLen:{mean:mean(lengths), sd:sd(lengths), N:lengths.length},
    fertileOffset:{mean:mean(fertOffsets), sd:sd(fertOffsets), N:fertOffsets.length},
    fertileLen:{mean:mean(fertLengths), sd:sd(fertLengths), N:fertLengths.length},
    ovulationDay:{mean:mean(ovDays), sd:sd(ovDays), N:ovDays.length},
    luteal:{mean:mean(luteals), sd:sd(luteals), N:luteals.length},
    coverline:{mean:mean(cover), sd:sd(cover), N:cover.length},
    postO:{mean:mean(postO), sd:sd(postO), N:postO.length},
    surge:{ cds: surgeCDs, q: quantiles(surgeCDs) }
  };
}

function renderCards(m){
  const cards=document.getElementById('cards');
  const f=(x,d)=>x==null?'—':(d===0? Math.round(x) : Number(x).toFixed(d));
  const r=(x)=>x==null?'—':Math.round(x); // whole numbers

  const it=(t,v,s)=>`<div class="card"><h3>${t}</h3><div class="value">${v}</div><div class="sub">${s||''}</div></div>`;
  cards.innerHTML=[
    it('Avg Cycle', `${r(m.cycleLen.mean)} d`, `±${f(m.cycleLen.sd,0)} (n=${m.cycleLen.N})`),
    it('Fertile Start', `${r(m.fertileOffset.mean)} d`, `after period (n=${m.fertileOffset.N})`),
    it('Fertile Length', `${f(m.fertileLen.mean,1)} d`, `±${f(m.fertileLen.sd,1)} (n=${m.fertileLen.N})`),
    it('Ovulation Day', `CD ${r(m.ovulationDay.mean)}`, `±${r(m.ovulationDay.sd)} (n=${m.ovulationDay.N})`),
    it('Luteal Length', `${r(m.luteal.mean)} d`, `±${r(m.luteal.sd)} (n=${m.luteal.N})`),
    it('Coverline (avg)', `${f(m.coverline.mean,2)} °C`, `n=${m.coverline.N}`),
    it('Post-O (avg)', `${f(m.postO.mean,2)} °C`, `n=${m.postO.N}`)
  ].join('');
}

function renderRibbons(cycles){
  const box=document.getElementById('ribbons'); box.innerHTML='';
  const completed=cycles.slice(-LAST_N);
  for(const c of completed){
    const unit=100/c.length; const bands=[];
    const p0=0, p1=Math.min(5,c.length); bands.push({left:p0*unit, width:(p1-p0)*unit, color:'var(--red)'});
    if(c.fertileStart && c.fertileEnd){
      const fs=dayDiff(c.startDate,c.fertileStart), fe=dayDiff(c.startDate,c.fertileEnd)+1;
      bands.push({left:fs*unit, width:(fe-fs)*unit, color:'var(--amber)'});
    }
    if(c.surgeDate){ const s=dayDiff(c.startDate,c.surgeDate); bands.push({left:s*unit, width:Math.max(1.5,unit*0.9), color:'var(--purple)'}); }
    if(c.ovulationDate){ const o=dayDiff(c.startDate,c.ovulationDate); bands.push({left:o*unit, width:Math.max(1.5,unit*0.9), color:'var(--blue)'}); }
    if(c.ovulationDate){ const o2=dayDiff(c.startDate,c.ovulationDate)+1; bands.push({left:o2*unit, width:(c.length-o2)*unit, color:'var(--green)'}); }
    const bandHTML=bands.map(b=>`<div class="band" style="left:${b.left}%;width:${b.width}%;background:${b.color}"></div>`).join('');
    const left=`${iso(c.startDate)} → ${iso(addDays(c.nextStart,-1))} · ${c.length}d`;
    const parts=[];
    if(c.coverline!=null) parts.push(`CL ${c.coverline.toFixed(2)}°C`);
    if(c.ovulationDate) parts.push(`O: CD ${dayDiff(c.startDate,c.ovulationDate)+1}`);
    if(c.lpdRisk) parts.push('LPD risk');
    if(c.anovSuspect) parts.push('Anov?');
    const right=parts.join(' · ') || '—';
    const div=document.createElement('div'); div.className='ribbon';
    div.innerHTML=`<div class="label"><span>${left}</span><span>${right}</span></div><div class="bar">${bandHTML}</div>`;
    box.appendChild(div);
  }
}

function renderInsights(cycles, m){
  const last = cycles.slice(-LAST_N);

  // Surge stats + strip
  const surgeStats = document.getElementById('surgeStats');
  const surgeNotes = document.getElementById('surgeNotes'); surgeNotes.innerHTML='';
  if(m.surge.q){
    const {median,q1,q3}=m.surge.q;
    surgeStats.textContent = `Median CD ${Math.round(median)} • IQR ${Math.round(q1)}–${Math.round(q3)} (n=${m.surge.cds.length})`;
  } else { surgeStats.textContent = 'No surge entries available'; }
  drawSurgeStrip(last);
  last.forEach((c)=>{ if(c.surgeCD==null){ const d=document.createElement('div'); d.innerHTML=`<span class="chip">${cycleMonthSpan(c)}</span> no numeric surge ≥ 0.75 / label`; surgeNotes.appendChild(d); }});

  // Post-O BBT dots vs coverline (full luteal)
  const riseList = document.getElementById('riseList'); 
  riseList.innerHTML = '';

  let totalDays = 0, totalHits = 0; // hits = days ≥ +0.20

  last.forEach((c)=>{
    if (c.coverline == null || !Array.isArray(c.postODeltas) || !c.postODeltas.length) return;

    const maxDPO = (typeof c.lutealLen === 'number' && c.lutealLen > 0) 
      ? c.lutealLen 
      : Math.max(...c.postODeltas.map(x=>x.dpo));

    const days = c.postODeltas
      .filter(x => x.dpo >= 1 && x.dpo <= maxDPO)
      .sort((a,b)=>a.dpo - b.dpo);

    const squares = days.map(x=>{
      const d = x.delta; 
      const eps = 1e-6;
      const cls = (d >= 0.20 - eps) ? 'green' : (d > 0 + eps ? 'red' : 'base');
      const title = `DPO${x.dpo}: ${(d>=0?'+':'')}${d.toFixed(2)} °C vs CL ${(c.coverline!=null)?c.coverline.toFixed(2):'—'}°C`;
      return `<span class="bbtDot ${cls}" title="${title}"></span>`;
    }).join('');

    const hits = days.filter(x=>x.delta >= 0.20 - 1e-6).length;
    totalDays += days.length; 
    totalHits += hits;

    // flags for this cycle (LPD / Anov)
    const flags = [];
    if (c.lpdRisk === true) flags.push('<span class="delta warn">LPD risk</span>');
    if (c.anovSuspect === true) flags.push('<span class="delta warn">Anov?</span>');

    const row = document.createElement('div');
    row.className = 'riseRow';
    row.innerHTML = `
      <span class="chip">${cycleMonthSpan(c)}</span>
      <div class="bbtBar">${squares}</div>
      <span class="delta ${hits>=6?'good':'warn'}">${hits}/${days.length} ≥ +0.20 °C</span>
      <span class="caption" style="margin-left:8px;color:var(--muted)">CL ${c.coverline!=null?c.coverline.toFixed(2):'—'}°C</span>
      ${flags.length ? `<span style="flex:1"></span>${flags.join('')}` : ''}
    `;
    riseList.appendChild(row);
  });

  const pct = totalDays ? Math.round(100 * totalHits / totalDays) : null;
  document.getElementById('riseStats').textContent = totalDays
    ? `${pct}% of luteal days ≥ +0.20 °C across shown cycles`
    : 'No post-O BBT data';

  // LPD matrix
  const lpdRows=[['Cycle','Luteal ≥ 9','DPO1–10 ≥ +0.20','No 2-day drop','No LPD risk']];
  last.forEach((c)=>{
    const lutealOK = (c.lutealLen!=null && c.lutealLen>=9) ? '✓' : '✗';
    const scoreText = (c.pScoreDen!=null) ? `${c.pScore}/${c.pScoreDen}` : '—';
    const noDrop = (c.hasMultiDayDrop==null) ? '—' : (c.hasMultiDayDrop? '✗' : '✓');
    const noRisk = (c.lpdRisk==null) ? '—' : (c.lpdRisk? '✗' : '✓');
    lpdRows.push([cycleMonthSpan(c), lutealOK, scoreText, noDrop, noRisk]);
  });
  renderMatrix('lpdMatrix', lpdRows);

  // Anovulation matrix
  const anovRows=[['Cycle','Numeric surge ≥ 0.75','Sustained shift (DPO1–10)','O inferred']];
  last.forEach((c)=>{
    const numOK = c.lhNumSurgePresent ? '✓' : '✗';
    const sustOK = (c.sustainedShiftProg==null) ? '—' : (c.sustainedShiftProg? '✓' : '✗');
    const inferred = (c.lhNumSurgePresent && c.sustainedShiftProg) ? '✓' : '✗';
    anovRows.push([cycleMonthSpan(c), numOK, sustOK, inferred]);
  });
  renderMatrix('anovMatrix', anovRows);

  // Sex timing
  const full3 = last.filter(c=>c.sexCoverageCount===3).length;
  const b0 = last.filter(c=>c.sexCoverageCount===0).length;
  const b1 = last.filter(c=>c.sexCoverageCount===1).length;
  const b2 = last.filter(c=>c.sexCoverageCount===2).length;
  const b3 = last.filter(c=>c.sexCoverageCount===3).length;
  document.getElementById('sexBreak').textContent = `0/3:${b0} • 1/3:${b1} • 2/3:${b2} • 3/3:${b3} • 100% hits: ${full3}/${last.length}`;

  const sexPills=document.getElementById('sexPills'); sexPills.innerHTML='';
  last.forEach((c)=>{
    const row=document.createElement('div'); row.className='pillRow';
    row.innerHTML = `<span class="chip">${cycleMonthSpan(c)}</span>
      <span class="pillLbl">-2</span><span class="dot ${c.sexDays4[0]?'on':''}"></span>
      <span class="pillLbl">-1</span><span class="dot ${c.sexDays4[1]?'on':''}"></span>
      <span class="pillLbl">0</span><span class="dot ${c.sexDays4[2]?'on':''}"></span>
      <span class="pillLbl">+1</span><span class="dot opt ${c.sexDays4[3]?'on':''}"></span>`;
    sexPills.appendChild(row);
  });
}

function drawSurgeStrip(cycles){
  const canvas=document.getElementById('surgeCanvas');
  const dpr=window.devicePixelRatio||1;
  const cssW=canvas.clientWidth, cssH=canvas.clientHeight;
  canvas.width=cssW*dpr; canvas.height=cssH*dpr;
  const ctx=canvas.getContext('2d'); ctx.scale(dpr,dpr);
  ctx.clearRect(0,0,cssW,cssH);

  const cds = cycles.map(c=>c.surgeCD).filter(v=>v!=null);
  let minCD = cds.length? Math.min(...cds) : 8;
  let maxCD = cds.length? Math.max(...cds) : 20;
  minCD=Math.max(6, Math.min(minCD, 12));
  maxCD=Math.min(28, Math.max(maxCD, 16));
  const left=36, right=cssW-12, center=cssH/2;

  ctx.strokeStyle="#ddd"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(left,center); ctx.lineTo(right,center); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font="11px system-ui"; ctx.textAlign="center";
  for(let cd=minCD; cd<=maxCD; cd+=2){
    const x = left + (cd-minCD)/(maxCD-minCD||1) * (right-left);
    ctx.beginPath(); ctx.moveTo(x, center-6); ctx.lineTo(x, center+6); ctx.stroke();
    ctx.fillText(String(cd), x, 14);
  }

  let row=0; const rows=3;
  cycles.forEach(c=>{
    const cd = c.surgeCD;
    if(cd==null) return;
    const x = left + (cd-minCD)/(maxCD-minCD||1) * (right-left);
    const y = center + ((row%rows)-1)*10; row++;
    ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fillStyle="rgba(209,95,167,0.9)"; ctx.fill();
  });
}

function renderMatrix(id, rows){
  const tbl=document.getElementById(id);
  let html='';
  rows.forEach((r,ri)=>{
    if(ri===0){
      html += '<tr>'+r.map(c=>`<th>${c}</th>`).join('')+'</tr>';
    }else{
      html += '<tr>'+r.map((c,ci)=>{
        if (ci===0) return `<td style="text-align:left">${c}</td>`;
        if (c==='✓') return `<td class="ok">✓</td>`;
        if (c==='✗') return `<td class="no">✗</td>`;
        return `<td>${c}</td>`;
      }).join('')+'</tr>';
    }
  });
  tbl.innerHTML=html;
}

/* ---------- Report (Share) ---------- */
function buildReportHTML(cycles, m, user){
  const limit = (typeof LAST_N === 'number' && LAST_N > 0) ? LAST_N : 12;
  const now = new Date();

  const fmt = (d)=> d ? new Date(d).toLocaleDateString() : '—';
  const r   = (x)=> x==null ? '—' : Math.round(x);
  const f2  = (x)=> x==null ? '—' : Number(x).toFixed(2);

  // --- STRICT numeric OPK from raw entries only (no label->number mapping) ---
  function numericLHOnDate(date, entries){
    if (!(date instanceof Date) || !Array.isArray(entries)) return null;
    const tgt = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())).getTime();
    let mx = null;
    for (const e of entries){
      if (!e || !(e._date instanceof Date)) continue;
      const t = new Date(Date.UTC(e._date.getFullYear(), e._date.getMonth(), e._date.getDate())).getTime();
      if (t !== tgt) continue;
      if (e.opk == null) continue;
      let s = String(e.opk).trim();
      // reject pure labels
      if (/\b(surge|solid|peak|static|flash|flashing|high|smiley)\b/i.test(s)) continue;
      // numeric parse (keep existing app behavior: remove % and convert commas)
      s = s.replace(/%/g,'').replace(',', '.');
      const n = parseFloat(s);
      if (!isFinite(n)) continue;
      mx = (mx==null ? n : Math.max(mx, n));
    }
    return mx;
  }

  // Build a clean per-day series with LH only when raw numeric exists.
  function seriesFor(c){
    const out=[];
    if (!c || !Array.isArray(c.entries)) return out;
    const startUTC = new Date(Date.UTC(c.startDate.getFullYear(), c.startDate.getMonth(), c.startDate.getDate()));
    for (const e of c.entries){
      if (!(e && e._date instanceof Date)) continue;
      const dUTC = new Date(Date.UTC(e._date.getFullYear(), e._date.getMonth(), e._date.getDate()));
      const cd = Math.max(1, Math.floor((dUTC - startUTC)/86400000)+1);
      const t  = (typeof e._bbt === 'number') ? e._bbt : null;
      // LH strictly from raw text if it contains a number
      let lh = null;
      if (e.opk != null){
        let s = String(e.opk).trim();
        if (!/\b(surge|solid|peak|static|flash|flashing|high|smiley)\b/i.test(s)){
          s = s.replace(/%/g,'').replace(',', '.');
          const n = parseFloat(s);
          if (isFinite(n)) lh = n;
        }
      }
      out.push({ cd, t, lh });
    }
    return out;
  }

  function monthSpan(c){
    const start=c.startDate, end=new Date(c.nextStart.getTime()-86400000);
    const ms=start.toLocaleString('en-US',{month:'short'}), me=end.toLocaleString('en-US',{month:'short'});
    const ys=start.getFullYear(), ye=end.getFullYear();
    return ys===ye ? `${ms}–${me}` : `${ms} ${ys}–${me} ${ye}`;
  }

  function lutealAvgTemp(c){
    if (!c || !Array.isArray(c.postODeltas) || !c.postODeltas.length) return null;
    const lutealTemps = c.postODeltas
      .filter(x => typeof x.temp === 'number' && x.dpo >= 1 && (typeof c.lutealLen === 'number' ? x.dpo <= c.lutealLen : true))
      .map(x => x.temp);
    if (!lutealTemps.length) return null;
    return lutealTemps.reduce((s,v)=>s+v,0)/lutealTemps.length;
  }

  // ---- table rows (show numeric only if raw numeric exists on the surge day) ----
  const rows = cycles.slice(-limit).map(c=>{
    const span   = monthSpan(c);
    const oDay   = c.ovulationDate? ( ( (c.ovulationDate - new Date(Date.UTC(c.startDate.getFullYear(), c.startDate.getMonth(), c.startDate.getDate())) )/86400000 ) + 1 ) : null;
    const sex    = c.sexDays4? ['-2','-1','0','+1'].map((_,i)=> c.sexDays4[i]?'●':'○').join(' ') : '—';
    const prog   = (c.pScoreDen!=null)? `${c.pScore}/${c.pScoreDen}` : '—';
    const anov   = (c.lhNumSurgePresent && c.sustainedShiftProg)? 'No' : 'Suspect';
    const lpd    = (c.lpdRisk==null)? '—' : (c.lpdRisk? 'Risk' : 'No risk');

    // Use whatever CD you computed; attach number only if raw numeric exists on that date
    let surgeCell = '—';
    if (c.surgeCD != null && c.surgeDate instanceof Date){
      const rawNum = numericLHOnDate(c.surgeDate, c.entries);
      surgeCell = rawNum!=null ? `CD ${c.surgeCD} (${f2(rawNum)})` : `CD ${c.surgeCD} (Predicted)`;
    }

    const lutAvg = lutealAvgTemp(c);

    return `
      <tr>
        <td>${span}</td>
        <td>${fmt(c.startDate)} → ${fmt(new Date(c.nextStart.getTime()-86400000))}</td>
        <td style="text-align:center">${c.length ?? '—'}</td>
        <td style="text-align:center">${surgeCell}</td>
        <td style="text-align:center">${oDay ?? '—'}</td>
        <td style="text-align:center">${c.lutealLen ?? '—'}</td>
        <td style="text-align:center">${c.coverline!=null? f2(c.coverline):'—'}</td>
        <td style="text-align:center">${lutAvg!=null? f2(lutAvg):'—'}</td>
        <td style="text-align:center">${prog}</td>
        <td style="text-align:center">${lpd}</td>
        <td style="text-align:center">${anov}</td>
        <td style="font-family:monospace">${sex}</td>
      </tr>`;
  }).join('');

  // ---- per-cycle visuals (charts use only numeric-from-raw for LH) ----
  const chartBlocks = cycles.slice(-limit).map((c)=>{
    const end = new Date(c.nextStart.getTime()-86400000);
    const title = `${c.startDate.toLocaleString('en-US',{month:'short'})} ${c.startDate.getFullYear()} – ${end.toLocaleString('en-US',{month:'short'})} ${end.getFullYear()}`;
    const payload = {
      title,
      series: seriesFor(c),
      coverline: (typeof c.coverline==='number') ? Number(c.coverline.toFixed(3)) : null,
      length: c.length,
      fertile: (c.fertileStart && c.fertileEnd) ? {
        fs: Math.floor((c.fertileStart - new Date(Date.UTC(c.startDate.getFullYear(), c.startDate.getMonth(), c.startDate.getDate())))/86400000),
        fe: Math.floor((c.fertileEnd   - new Date(Date.UTC(c.startDate.getFullYear(), c.startDate.getMonth(), c.startDate.getDate())))/86400000)+1
      } : null,
      surgeCD: c.surgeCD ?? null,
      ovCD: c.ovulationDate? Math.floor((c.ovulationDate - new Date(Date.UTC(c.startDate.getFullYear(), c.startDate.getMonth(), c.startDate.getDate())))/86400000) : null
    };
    const payloadAttr = JSON.stringify(payload).replace(/'/g, "&apos;");
    return `
      <div class="cycle-block" data-payload='${payloadAttr}'>
        <div class="cycle-title">${title}</div>
        <div class="ribbon-wrap"><div class="ribbon-bar"></div></div>
        <canvas class="cycle-chart" width="960" height="260"></canvas>
      </div>`;
  }).join('');

  const html = `
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Cycle Report</title>
<style>
  :root{
    --bg:#fffafc; --ink:#222; --muted:#6b6b6b; --card:#ffffff; --brand:#88a58d;
    --red:#f28b82; --green:#a5d6a7; --blue:#8ab4f8; --amber:#fbc02d; --purple:#d15fa7;
    --line:#e9ecef; --chip:#f1f3f4;
  }
  *{box-sizing:border-box}
  body{font-family:"Segoe UI",system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--ink);margin:24px}
  h1{margin:0 0 6px;font-size:22px}
  .sub{color:var(--muted);font-size:12px;margin-bottom:16px}
  .summary{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;margin:16px 0}
  .card{border:1px solid #eee;background:var(--card);border-radius:14px;padding:10px;box-shadow:0 2px 6px rgba(0,0,0,.04)}
  .card h3{font-size:11px;color:var(--muted);margin:0 0 4px}
  .card .val{font-size:18px;font-weight:700}
  .card .cap{font-size:11px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:12px;background:#fff;border:1px solid #eee;border-radius:12px;overflow:hidden}
  th,td{border-bottom:1px solid var(--line);padding:10px;text-align:left}
  thead th{background:#f8fafb;font-weight:600;color:var(--muted)}
  tr:last-child td{border-bottom:none}
  .legend{display:flex;gap:12px;flex-wrap:wrap;margin:10px 0 14px;font-size:12px;color:var(--muted)}
  .sw{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:4px;vertical-align:middle}
  .vis-section{margin-top:22px}
  .vis-header{font-size:14px;font-weight:600;margin:0 0 8px}
  .cycle-block{border:1px solid #eee;background:#fff;border-radius:12px;padding:12px;box-shadow:0 2px 6px rgba(0,0,0,.04);margin-bottom:12px}
  .cycle-title{font-size:13px;color:var(--muted);margin-bottom:6px}
  .ribbon-wrap{height:12px;background:#f3f3f3;border:1px solid #eee;border-radius:999px;position:relative;margin-bottom:10px;overflow:hidden}
  .ribbon-band{position:absolute;top:0;bottom:0;border-radius:999px}
  .no-print{display:flex;gap:8px;justify-content:flex-end;margin-bottom:8px}
  .btn{padding:8px 12px;border:1px solid var(--line);border-radius:10px;background:#fff;cursor:pointer}
  @media print { body{margin:12mm} .no-print{display:none} }
</style>
</head>
<body>
  <div class="no-print">
    <button onclick="window.print()" class="btn">Print / Save as PDF</button>
  </div>
  <h1>Cycle Summary Report</h1>
  <div class="sub">Generated ${now.toLocaleString()}${user? ` • ${user.email||user.displayName||''}`:''}</div>

  <div class="summary">
    <div class="card"><h3>Avg Cycle</h3><div class="val">${r(m.cycleLen.mean)} d</div><div class="cap">±${r(m.cycleLen.sd)} (n=${m.cycleLen.N})</div></div>
    <div class="card"><h3>Fertile Start</h3><div class="val">${r(m.fertileOffset.mean)} d</div><div class="cap">after period (n=${m.fertileOffset.N})</div></div>
    <div class="card"><h3>Fertile Length</h3><div class="val">${m.fertileLen.mean!=null? m.fertileLen.mean.toFixed(1):'—'} d</div><div class="cap">±${m.fertileLen.sd!=null? m.fertileLen.sd.toFixed(1):'—'} (n=${m.fertileLen.N})</div></div>
    <div class="card"><h3>Ovulation Day</h3><div class="val">CD ${r(m.ovulationDay.mean)}</div><div class="cap">±${r(m.ovulationDay.sd)} (n=${m.ovulationDay.N})</div></div>
    <div class="card"><h3>Luteal Length</h3><div class="val">${r(m.luteal.mean)} d</div><div class="cap">±${r(m.luteal.sd)} (n=${m.luteal.N})</div></div>
    <div class="card"><h3>Coverline (avg)</h3><div class="val">${m.coverline.mean!=null? m.coverline.mean.toFixed(2):'—'} °C</div><div class="cap">n=${m.coverline.N}</div></div>
    <div class="card"><h3>Avg Luteal Temp</h3><div class="val">${m.postO.mean!=null? m.postO.mean.toFixed(2):'—'} °C</div><div class="cap">n=${m.postO.N}</div></div>
  </div>

  <table>
    <thead>
      <tr>
        <th>Cycle</th>
        <th>Dates</th>
        <th>Len</th>
        <th>LH Surge (CD)</th>
        <th>Ovul. (CD)</th>
        <th>Luteal Days</th>
        <th>Coverline</th>
        <th>Avg Luteal Temp</th>
        <th>P-score (DPO1–10)</th>
        <th>LPD</th>
        <th>Anovulation</th>
        <th>Sex Timing (-2 -1 0 +1)</th>
      </tr>
    </thead>
    <tbody>${rows}</tbody>
  </table>

  <div class="legend">
    <span><span class="sw" style="background:var(--red)"></span>Period</span>
    <span><span class="sw" style="background:var(--amber)"></span>Fertile</span>
    <span><span class="sw" style="background:var(--purple)"></span>Surge</span>
    <span><span class="sw" style="background:var(--blue)"></span>Ovulation</span>
    <span><span class="sw" style="background:var(--green)"></span>Luteal</span>
  </div>

  <div class="vis-section">
    <div class="vis-header">Per-cycle visuals</div>
    ${chartBlocks}
  </div>

  <script>
  (function(){
    function drawRibbon(container, payload){
      const bar = container.querySelector('.ribbon-bar');
      const L = payload.length || 0;
      if(!L){ return; }
      const css = getComputedStyle(document.documentElement);
      const bands = [];
      const p0=0, p1=Math.min(5,L); bands.push({left:p0, width:(p1-p0), color:css.getPropertyValue('--red')});
      if(payload.fertile){ bands.push({left:payload.fertile.fs, width:(payload.fertile.fe - payload.fertile.fs), color:css.getPropertyValue('--amber')}); }
      if(typeof payload.surgeCD === 'number'){ bands.push({left:payload.surgeCD-1, width:1, color:css.getPropertyValue('--purple')}); }
      if(typeof payload.ovCD === 'number'){ bands.push({left:payload.ovCD, width:1, color:css.getPropertyValue('--blue')}); }
      if(typeof payload.ovCD === 'number'){ const o2 = payload.ovCD + 1; bands.push({left:o2, width:(L - o2), color:css.getPropertyValue('--green')}); }
      const unit = 100 / L;
      bar.innerHTML = bands.map(b => {
        const left = b.left * unit;
        const width = Math.max(1.5, b.width * unit);
        return '<span class="ribbon-band" style="left:'+left+'%;width:'+width+'%;background:'+b.color+'"></span>';
      }).join('');
    }

    function drawChart(canvas, series, coverline){
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

      const bbtPts = series.filter(p=>typeof p.t==='number');
      const lhPts  = series.filter(p=>typeof p.lh==='number');
      if(!bbtPts.length && !lhPts.length){
        ctx.fillStyle='#999'; ctx.font='12px system-ui'; ctx.fillText('No data', 12, 16); return;
      }

      const xs = series.map(p=>p.cd);
      const minX = Math.min(...xs), maxX = Math.max(...xs);

      let bbtMin = bbtPts.length ? Math.min(...bbtPts.map(p=>p.t)) : 36.0;
      let bbtMax = bbtPts.length ? Math.max(...bbtPts.map(p=>p.t)) : 37.5;
      if(typeof coverline==='number'){ bbtMin = Math.min(bbtMin, coverline - 0.10); bbtMax = Math.max(bbtMax, coverline + 0.10); }
      if(bbtMax - bbtMin < 0.3){ bbtMax = bbtMin + 0.3; }

      const padL=40, padR=40, padT=16, padB=26;
      const x2px = x => padL + ((x - minX)/((maxX-minX)||1)) * (W - padL - padR);
      const y2pxBBT = y => H - padB - ((y - bbtMin)/(bbtMax - bbtMin)) * (H - padT - padB);
      const y2pxLH  = y => H - padB - (y * (H - padT - padB)); // LH scale 0..1 or user-entered scale

      // axes & ticks
      ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H-padB); ctx.lineTo(W-padR, H-padB); ctx.stroke();
      ctx.fillStyle = '#6b6b6b'; ctx.font='10px system-ui';
      for(let cd=minX; cd<=maxX; cd+=2){
        const x = x2px(cd);
        ctx.beginPath(); ctx.moveTo(x, H-padB); ctx.lineTo(x, H-padB+4); ctx.strokeStyle='#e5e7eb'; ctx.stroke();
        ctx.fillText(String(cd), x-4, H-6);
      }

      // coverline
      if(typeof coverline==='number'){
        ctx.setLineDash([4,4]); ctx.strokeStyle='#6b7280';
        ctx.beginPath(); ctx.moveTo(padL, y2pxBBT(coverline)); ctx.lineTo(W-padR, y2pxBBT(coverline)); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle='#6b7280'; ctx.font='11px system-ui';
        ctx.fillText('CL '+coverline.toFixed(2)+'°C', padL+6, y2pxBBT(coverline)-4);
      }

      // BBT
      if(bbtPts.length){
        ctx.strokeStyle='#111'; ctx.lineWidth=2;
        ctx.beginPath();
        bbtPts.forEach((p,i)=>{ const x=x2px(p.cd), y=y2pxBBT(p.t); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();
        ctx.fillStyle='#111';
        bbtPts.forEach(p=>{ const x=x2px(p.cd), y=y2pxBBT(p.t); ctx.beginPath(); ctx.arc(x,y,2.5,0,Math.PI*2); ctx.fill(); });
      }

      // LH (only numeric-from-raw)
      if(lhPts.length){
        const purple = getComputedStyle(document.documentElement).getPropertyValue('--purple') || '#d15fa7';
        ctx.strokeStyle=purple; ctx.lineWidth=2;
        ctx.beginPath();
        lhPts.forEach((p,i)=>{ const x=x2px(p.cd), y=y2pxLH(p.lh); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();
        ctx.fillStyle=purple;
        lhPts.forEach(p=>{ const x=x2px(p.cd), y=y2pxLH(p.lh); ctx.beginPath(); ctx.arc(x,y,2.5,0,Math.PI*2); ctx.fill(); });
      }
    }

    document.querySelectorAll('.cycle-block').forEach(block=>{
      const payload = JSON.parse(block.getAttribute('data-payload') || '{}');
      // ribbon
      (function(container, payload){
        const bar = container.querySelector('.ribbon-bar');
        const L = payload.length || 0;
        if(!L){ return; }
        const css = getComputedStyle(document.documentElement);
        const bands = [];
        const p0=0, p1=Math.min(5,L); bands.push({left:p0, width:(p1-p0), color:css.getPropertyValue('--red')});
        if(payload.fertile){ bands.push({left:payload.fertile.fs, width:(payload.fertile.fe - payload.fertile.fs), color:css.getPropertyValue('--amber')}); }
        if(typeof payload.surgeCD === 'number'){ bands.push({left:payload.surgeCD-1, width:1, color:css.getPropertyValue('--purple')}); }
        if(typeof payload.ovCD === 'number'){ bands.push({left:payload.ovCD, width:1, color:css.getPropertyValue('--blue')}); }
        if(typeof payload.ovCD === 'number'){ const o2 = payload.ovCD + 1; bands.push({left:o2, width:(L - o2), color:css.getPropertyValue('--green')}); }
        const unit = 100 / L;
        bar.innerHTML = bands.map(b => {
          const left = b.left * unit;
          const width = Math.max(1.5, b.width * unit);
          return '<span class="ribbon-band" style="left:'+left+'%;width:'+width+'%;background:'+b.color+'"></span>';
        }).join('');
      })(block.querySelector('.ribbon-wrap'), payload);

      drawChart(block.querySelector('canvas.cycle-chart'), payload.series || [], payload.coverline);
    });
  })();
  <\/script>

  <div class="sub" style="margin-top:18px;color:var(--muted)">
    Notes: LH value shown only when a numeric reading exists on the surge day; otherwise “Predicted”. Labels like “Surge/Peak/High” are not converted to numbers in this report.
  </div>
</body>
</html>
  `;

  return html;
}

function openReportWindow(cycles, metrics, user){
  const html = buildReportHTML(cycles, metrics, user);
  const w = window.open('', '_blank');
  if (!w) return alert('Popup blocked. Please allow popups to generate the report.');
  w.document.open(); w.document.write(html); w.document.close();
}

/* ---------- Orchestration ---------- */
let CURRENT_CYCLES=[];
let CURRENT_USER=null;

function renderAll(){
  if(!ENTRIES.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>No data</h3><div class="value">—</div><div class="sub">No entries</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  const cycles=segmentCycles(ENTRIES);
  if(!cycles.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>Setup</h3><div class="value">0 cycles</div><div class="sub">Add Day 1 (period start) entries.</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  CURRENT_CYCLES=cycles;
  const m=computeMetrics(cycles);
  renderCards(m);
  renderRibbons(cycles);
  renderInsights(cycles, m);
  console.log('[history] surge CDs:', cycles.map(c=>c.surgeCD), 'lengths:', cycles.map(c=>c.length));
}

document.getElementById('homeBtn').addEventListener('click',()=>{ window.location.href='index.html'; });
document.getElementById('shareBtn').addEventListener('click', async ()=>{
  try{ CURRENT_USER = firebase.auth().currentUser || null; }catch{} 
  const m = computeMetrics(CURRENT_CYCLES||[]);
  openReportWindow(CURRENT_CYCLES||[], m, CURRENT_USER);
});
</script>
</body>
</html>
