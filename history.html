<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>History</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="js/firebase-config.js"></script>

<style>
:root{
  --bg:#fffafc; --ink:#222; --muted:#6b6b6b; --card:#ffffff; --brand:#88a58d;
  --red:#f28b82; --green:#a5d6a7; --blue:#8ab4f8; --amber:#fbc02d; --purple:#d15fa7;
  --line:#e9ecef; --chip:#f1f3f4;
}
*{box-sizing:border-box}
html,body{max-width:100%; overflow-x:hidden;}
body{margin:0;background:var(--bg);color:var(--ink);font-family:"Segoe UI",system-ui,-apple-system,sans-serif}
header{position:sticky;top:0;background:var(--bg);z-index:10;padding:12px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;gap:8px}
header h1{font-size:18px;margin:0;font-weight:600}
header .spacer{flex:1}
header button{border:none;background:var(--brand);color:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
header .ghost{background:#e9efe9;color:#2f4733}

.page{max-width:960px;margin:0 auto;}

.cards{display:flex;gap:10px;overflow:auto;padding:12px 12px 4px}
.card{min-width:160px;background:var(--card);border:1px solid #eee;border-radius:14px;padding:10px;box-shadow:0 2px 6px rgba(0,0,0,.04)}
.card h3{font-size:12px;color:var(--muted);margin:0 0 6px}
.card .value{font-size:22px;font-weight:700}
.card .sub{font-size:12px;color:var(--muted)}

.section{padding:8px 12px}
.section h2{font-size:16px;margin:8px 0}

.ribbons{display:flex;flex-direction:column;gap:10px}
.ribbonLink{display:block;text-decoration:none;color:inherit}
.ribbon{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px;transition:box-shadow .15s, transform .06s}
.ribbon:hover{box-shadow:0 4px 16px rgba(0,0,0,.06)}
.ribbon:active{transform:scale(.998)}
.ribbon .label{font-weight:600;font-size:13px;margin-bottom:6px;display:flex;justify-content:space-between;color:var(--muted);gap:8px;flex-wrap:wrap}
.bar{position:relative;height:10px;background:#f3f3f3;border-radius:999px;overflow:hidden}
.band{position:absolute;top:0;bottom:0;border-radius:999px}
.legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted)}
.swatch{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:4px;vertical-align:middle}

.grid{display:grid;grid-template-columns:1fr;gap:12px;padding:8px 12px}
@media(min-width:560px){.grid{grid-template-columns:1fr 1fr}}

.panel{background:var(--card);border:1px solid #eee;border-radius:12px;padding:10px}
.panel h3{font-size:14px;margin:0 0 4px}
.panel .caption{font-size:12px;color:var(--muted);margin-bottom:8px}
.reasons{font-size:12px;color:var(--ink);display:flex;flex-direction:column;gap:4px;margin-top:6px}
.chip{display:inline-block;background:var(--chip);border:1px solid #e2e6ea;border-radius:999px;padding:2px 8px;margin-right:6px;font-size:12px}
.line{font-size:12px}

/* BBT rise bars / dots */
.riseRow{display:flex;align-items:center;gap:8px;padding:6px 8px;border:1px solid var(--line);border-radius:10px;overflow-x:auto}
.delta{font-size:12px;font-weight:700;padding:2px 8px;border-radius:999px;white-space:nowrap}
.delta.good{background:rgba(165,214,167,.25);border:1px solid #a5d6a7}
.delta.warn{background:rgba(242,139,130,.25);border:1px solid #f28b82}

/* Matrices */
.matrixWrap{overflow-x:auto;-webkit-overflow-scrolling:touch}
.matrix{min-width:520px;width:100%;border-collapse:collapse;font-size:12px;margin-top:6px}
.matrix th,.matrix td{border:1px solid #eee;padding:6px;text-align:center;white-space:nowrap}
.matrix th{background:#fafafa;font-weight:600;color:var(--muted)}
.ok{color:#2e7d32;font-weight:700}
.no{color:#c62828;font-weight:700}

/* Surge strip */
#surgeCanvas{width:100%;height:90px;border:1px solid #eee;border-radius:8px;background:#fff}

/* Sex timing row */
.pillRow{display:flex;align-items:center;gap:8px;overflow-x:auto}
.pillLbl{width:28px;font-size:11px;color:var(--muted);text-align:right;flex:0 0 auto}
.dot{width:14px;height:14px;border-radius:50%;border:2px solid #cbd5e1;background:#fff}
.dot.on{background:var(--blue);border-color:var(--blue)}
.dot.opt{opacity:.45}

/* Post-ovulation BBT dots — keep horizontal on mobile */
.bbtBar{
  display:flex;
  gap:4px;
  align-items:center;
  min-height:16px;
  flex-wrap:nowrap;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
}
.bbtBar:empty{display:none}
.bbtDot{width:14px;height:14px;border-radius:3px;border:1px solid #cbd5e1;background:#111;flex:0 0 auto}
.bbtDot.red{background:var(--red);}
.bbtDot.green{background:var(--green);}
.bbtDot.base{background:#111;}

/* Mobile polish */
@media (max-width: 600px){
  .section{padding:8px}
  .legend{font-size:11px}
  .ribbon .label{font-size:12px}
  .cards{padding:10px}
}
</style>
</head>
<body>
<header class="page">
  <button class="ghost" id="homeBtn">Home</button>
  <h1>History</h1>
  <div class="spacer"></div>
  <button id="shareBtn">Share</button>
</header>

<div class="page">
  <div class="cards" id="cards"></div>

  <div class="section">
    <h2>Completed Cycles</h2>
    <div class="ribbons" id="ribbons"></div>
    <div class="legend">
      <span><span class="swatch" style="background:var(--red)"></span>Period</span>
      <span><span class="swatch" style="background:var(--amber)"></span>Fertile</span>
      <span><span class="swatch" style="background:var(--purple)"></span>Surge</span>
      <span><span class="swatch" style="background:var(--blue)"></span>Ovulation</span>
      <span><span class="swatch" style="background:var(--green)"></span>Luteal</span>
    </div>
  </div>

  <div class="section"><h2>Insights & Trends</h2></div>
  <div class="grid">
    <div class="panel">
      <h3>LH surge day (CD)</h3>
      <div class="caption" id="surgeStats">—</div>
      <canvas id="surgeCanvas"></canvas>
      <div id="surgeNotes" class="reasons"></div>
    </div>

    <div class="panel">
      <h3>BBT rise per cycle</h3>
      <div class="caption">Post-ovulation daily temps vs coverline through full luteal: <b style="color:var(--green)">Green</b> ≥ +0.20 °C, <b style="color:var(--red)">Red</b> = +0.10…+0.19 °C, <b>Black</b> ≤ +0.09 °C.</div>
      <div class="caption" id="riseStats">—</div>
      <div id="riseList" class="reasons"></div>
    </div>

    <div class="panel">
      <h3>LPD risk (low progesterone)</h3>
      <div class="matrixWrap"><table class="matrix" id="lpdMatrix"></table></div>
    </div>

    <div class="panel">
      <h3>Anovulation suspect</h3>
      <div class="matrixWrap"><table class="matrix" id="anovMatrix"></table></div>
    </div>

    <div class="panel">
      <h3>Sex timing — ideal vs met</h3>
      <div class="caption" id="sexStats">Ideal −2, −1, 0 (+1 optional). Filled = met.</div>
      <div id="sexBreak" class="line"></div>
      <div id="sexPills" class="reasons"></div>
    </div>
  </div>
</div>

<script>
console.log('[history] build 2025-08-14 v12: mobile polish + ribbons link to summary');

/* ---------- Config ---------- */
const LAST_N = 12; // show last N completed cycles

/* ---------- Date helpers ---------- */
function toUTCmid(d){ return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); }
function addDays(d,n){ const x=new Date(d.getTime()); x.setDate(x.getDate()+n); return x; }
function dayDiff(a,b){ if(!(a instanceof Date)||!(b instanceof Date)) return 0; const A=toUTCmid(a), B=toUTCmid(b); return Math.max(0, Math.floor((B-A)/86400000)); }
function iso(d){ return (d instanceof Date && !isNaN(d.getTime())) ? d.toISOString().slice(0,10) : '—'; }
function monthShort(d){ return d.toLocaleString('en-US',{month:'short'}); }
function cycleMonthSpan(c){
  const start=c.startDate, end=addDays(c.nextStart,-1);
  const ms=monthShort(start), me=monthShort(end);
  const ys=start.getFullYear(), ye=end.getFullYear();
  return ys===ye ? `${ms}–${me}` : `${ms} ${ys}–${me} ${ye}`;
}

/* ---------- Parse entry DATE ---------- */
function stripAtTail(s){ const i=s.indexOf(' at '); return i>=0? s.slice(0,i) : s; }
function parseAnyDate(v){
  if(v==null) return null;
  if(v instanceof Date) return isNaN(v.getTime())? null : v;
  if(typeof v==='number'){ const d=new Date(v); return isNaN(d.getTime())? null : d; }
  let s=String(v).trim(); s=stripAtTail(s);
  let m=/^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s); if(m){ const D=new Date(+m[1],+m[2]-1,+m[3]); return isNaN(D)?null:D; }
  m=/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})$/.exec(s);
  if(m){ const MONTHS={jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11}; const D=new Date(+m[3],MONTHS[m[2].slice(0,3).toLowerCase()],+m[1]); return isNaN(D)?null:D; }
  const D=new Date(s); return isNaN(D)? null : D;
}
function getEntryDate(e){
  const fields=[e.entryDate, e['entry-date'], e.entry_date, e.date, e.Date];
  for(const v of fields){ const d=parseAnyDate(v); if(d) return d; }
  if (typeof e.id === 'string') {
    const m=/^(\d{4})-(\d{2})-(\d{2})$/.exec(e.id);
    if (m) { const D=new Date(+m[1],+m[2]-1,+m[3]); if(!isNaN(D)) return D; }
  }
  return null;
}

/* ---------- BBT parsing ---------- */
function parseBBT(v){
  if(v==null) return null;
  if(typeof v==='number'){ let n=v; if(n>80) n=(n-32)*5/9; if(n<35||n>38.5) return null; return n; }
  let s=String(v).trim().replace(/[^\d.,\-]/g,''); if(s.includes(',')&&!s.includes('.')) s=s.replace(',','.');
  let n=parseFloat(s); if(!isFinite(n)) return null; if(n>80) n=(n-32)*5/9; if(n<35||n>38.5) return null; return n;
}

/* ---------- OPK helpers ---------- */
function opkAsNumber(v){
  if (v == null) return null;
  if (typeof v === 'number') return v;
  let s = String(v).trim().toLowerCase();
  s = s.replace(/[%]/g,'').replace(',', '.');
  if (/\b(surge|solid|peak|static)\b/.test(s)) return 1.0;        // labels used only for visuals
  if (/\b(flash|flashing|high|smiley)\b/.test(s)) return 0.5;
  const n = parseFloat(s); return isFinite(n)? n : null;
}
function isLabeledSurge(v){ if(v==null) return false; return /\b(surge|solid|peak|static)\b/i.test(String(v)); }
function isLabeledFertile(v){ if(v==null) return false; return /\b(flash|flashing|high|smiley)\b/i.test(String(v)); }
function opkClass(v){
  if (v == null) return 'none';
  const n = opkAsNumber(v);
  if (isLabeledSurge(v) || (n!=null && n>=0.75)) return 'surge';
  if (isLabeledFertile(v) || (n!=null && n>=0.30 && n<=0.74)) return 'fertile';
  return 'none';
}
function cmScore(cm){
  if(!cm) return 0; const s=String(cm).toLowerCase();
  if(s.includes('egg')) return 4; if(s.includes('watery')) return 3; if(s.includes('creamy')) return 2; if(s.includes('sticky')) return 1;
  return 0;
}

/* ---------- Day1 detector ---------- */
function isDay1(e){
  const ph=(e.phase||'').toLowerCase().replace(/[^a-z0-9]/g,'');
  return ph==='day1period' || ph==='periodstart' || e.day1===true;
}

/* ---------- Firestore load, per-field merge, per-day compress ---------- */
let ENTRIES=[];
firebase.auth().onAuthStateChanged(async function(u){
  if(!u){ window.location.href='index.html'; return; }

  function normalizeDoc(d){
    const o=d.data(); o.id=d.id; o._src=d.ref.path;
    o._date = getEntryDate(o);
    o._key  = o._date? iso(o._date) : null;
    o._bbt  = parseBBT(o.bbt);
    o._raw = {
      entryDate: o.entryDate ?? o['entry-date'] ?? o.entry_date ?? o.date ?? o.Date ?? null,
      timestamp: o.timestamp ?? o.Timestamp ?? null,
      opk: o.opk ?? null
    };
    return o;
  }

  const db = firebase.firestore();

  const guesses = [];
  if (u && u.uid) guesses.push(u.uid);
  if (u && u.displayName) guesses.push(u.displayName);
  if (u && u.email) { const local = String(u.email).split('@')[0]; if (local && !guesses.includes(local)) guesses.push(local); }

  const queries = [];
  queries.push(db.collection('entries').get().then(s=>s.docs.map(normalizeDoc)).catch(()=>[])); // top-level
  for (const key of guesses) {
    queries.push(
      db.collection('users').doc(key).collection('entries').get()
        .then(s=>s.docs.map(normalizeDoc))
        .catch(()=>[])
    );
  }

  try{
    const results = await Promise.all(queries);
    const all = results.flat();

    const buckets = {};
    for (const e of all) {
      if (!e._key) continue;
      (buckets[e._key] ||= []).push(e);
    }

    const daily=[];
    const keys=Object.keys(buckets).sort();
    for(const k of keys){
      const arr=buckets[k];

      const userFirst = arr.find(x=>String(x._src||'').includes('/users/')) || arr[0];
      const base = { id:userFirst.id, _src:userFirst._src, _date:userFirst._date, _key:k };

      // BBT
      let bbt=null;
      for(const e of arr){ if(String(e._src||'').includes('/users/') && e._bbt!=null) { bbt=e._bbt; break; } }
      if(bbt==null){ for(const e of arr){ if(e._bbt!=null){ bbt=e._bbt; break; } } }
      base._bbt = bbt; base.bbt = bbt;

      // OPK precedence (per day)
      let hasLabelSurge=false, hasLabelFertile=false, maxNum=null;
      for(const e of arr){
        if(isLabeledSurge(e.opk)) hasLabelSurge=true;
        if(isLabeledFertile(e.opk)) hasLabelFertile=true;
        const n=opkAsNumber(e.opk);
        if(n!=null) maxNum = (maxNum==null? n : Math.max(maxNum, n));
      }
      if (hasLabelSurge || (maxNum!=null && maxNum>=0.75)) base.opk = 'Surge';
      else if (hasLabelFertile || (maxNum!=null && maxNum>=0.30 && maxNum<=0.74)) base.opk = 'Flashing';
      else base.opk = '';
      base._opkNum = (maxNum!=null? maxNum : (hasLabelSurge? 1.0 : null));

      base.sex = arr.some(e=>String(e.sex||'').toLowerCase()==='yes') ? 'yes' : '';

      let bestCM=null, bestScore=-1;
      for(const e of arr){ const sc=cmScore(e.cm); if(sc>bestScore){ bestScore=sc; bestCM=e.cm; } }
      base.cm = bestCM;

      base.day1 = arr.some(e=>isDay1(e));
      base.phase = base.day1 ? 'day1-period' : (arr.find(e=>e.phase)?.phase || '');

      const hasSymptoms = arr.some(e=>{
        if (e.symptoms && String(e.symptoms).trim()!=='') return true;
        if (Array.isArray(e.symptomList) && e.symptomList.length>0) return true;
        return false;
      });
      base._hasSymptoms = hasSymptoms;

      daily.push(base);
    }

    ENTRIES=daily;
    renderAll();
  }catch(err){
    document.getElementById('cards').innerHTML='<div class="card"><h3>Error</h3><div class="value">—</div><div class="sub">'+(err&&err.message?err.message:'Query failed')+'</div></div>';
  }
});

/* --- BBT shift & coverline --- */
function detectBbtShiftAndCoverline(segSorted, offsetC = 0.05) {
  const days = segSorted
    .filter(e => e._bbt != null)
    .map(e => ({ d: toUTCmid(e._date), t: e._bbt }))
    .sort((a,b)=> a.d - b.d);

  if (days.length < 10) return null;

  const T = days.map(x => x.t);

  for (let i = 6; i + 3 < T.length; i++) {
    const pre6      = T.slice(i-6, i);
    const pre6max   = Math.max.apply(null, pre6);
    const coverline = pre6max + offsetC;

    const next4 = [T[i], T[i+1], T[i+2], T[i+3]];
    const hits  = next4.filter(v => v >= coverline - 1e-6).length;

    if (hits >= 3) {
      const shiftIndex = i;
      const shiftDate  = days[shiftIndex].d;
      const ovDate     = addDays(shiftDate, -1);

      const postODeltas = days
        .map(x => ({ dpo: dayDiff(ovDate, x.d), temp: x.t }))
        .filter(x => x.dpo >= 1)
        .map(x => ({ ...x, delta: x.temp - coverline }));

      return {
        shiftIndex, shiftDate, ovDate, coverline,
        pre6max, pre6Window: days.slice(i-6, i).map(x => ({ date: iso(x.d), t: x.t })),
        postODeltas,
        method: `BBT shift: max of previous 6 + ${offsetC.toFixed(2)}°C`
      };
    }
  }
  return null;
}

/* ---------- Cycle building & metrics ---------- */
function buildCycle(seg, startDate, nextStart) {
  const segSorted = seg.slice().sort((a,b) => a._date - b._date);

  // Map OPK per day
  const S = segSorted.map(e => {
    const nRaw  = (e._opkNum != null ? e._opkNum : opkAsNumber(e.opk));
    const label = isLabeledSurge(e.opk);
    const cls   = (label || (nRaw != null && nRaw >= 0.75)) ? 'surge'
                 : (isLabeledFertile(e.opk) || (nRaw != null && nRaw >= 0.30 && nRaw <= 0.74)) ? 'fertile'
                 : 'none';
    const nEff  = (nRaw != null ? nRaw : (label ? 1.0 : null));
    return { e, d: toUTCmid(e._date), nRaw, nEff, label, cls };
  });

  // Numeric-only surge evidence
  let lhNumSurgePresent = false;
  let surgeNumDate = null;
  for (const x of S) {
    if (typeof x.nRaw === 'number' && x.nRaw >= 0.75) {
      lhNumSurgePresent = true;
      if (!surgeNumDate) surgeNumDate = x.d;
    }
  }

  // Runs for visuals (labels allowed)
  let surgeDate = null;
  let runs = [], cur = null;
  S.forEach((x,i) => {
    if (x.cls === 'surge') {
      if (!cur) cur = { start:i, end:i, peakI:i, peakV:(x.nEff ?? -Infinity) };
      else { cur.end = i; if ((x.nEff ?? -Infinity) > cur.peakV) { cur.peakV = x.nEff; cur.peakI = i; } }
    } else { if (cur) { runs.push(cur); cur = null; } }
  });
  if (cur) runs.push(cur);
  if (runs.length) {
    let best = runs[0];
    for (const r of runs) {
      if (r.peakV > best.peakV) best = r;
      else if (r.peakV === best.peakV && S[r.peakI].d < S[best.peakI].d) best = r;
    }
    surgeDate = S[best.peakI].d;
  }

  // Anchor ovulation to numeric surge when present
  const surgeAnchor = surgeNumDate || surgeDate;
  const ovulationDate = surgeAnchor ? addDays(surgeAnchor, 1) : null;
  const surgeCD = surgeAnchor ? (dayDiff(startDate, surgeAnchor) + 1) : null;

  // Fertile window
  const periodEnd = addDays(startDate, 4);
  let fertileStart = null, fertileEnd = null;
  if (ovulationDate){
    const lastPreO = addDays(ovulationDate,-1);
    for (const e of segSorted){
      const d = toUTCmid(e._date);
      if (d <= periodEnd) continue;
      if (d > lastPreO) break;
      if (opkClass(e.opk)==='fertile' || (e._opkNum!=null && e._opkNum>=0.30 && e._opkNum<=0.74)){
        if(!fertileStart) fertileStart = d;
        fertileEnd = d;
      }
    }
    if (!fertileStart) fertileStart = addDays(ovulationDate,-5);
    if (!fertileEnd)   fertileEnd   = lastPreO;
    if (fertileStart && fertileStart <= periodEnd) fertileStart = addDays(periodEnd,1);
  }

  // Luteal length
  const lutealLen = (ovulationDate ? dayDiff(ovulationDate, nextStart) : null);

  // BBT coverline & deltas
  let coverline = null, postOMean = null, risePreToDPO = null;
  let _postODeltas = [];
  let _clMeta = null;

  const bbtShift = detectBbtShiftAndCoverline(segSorted, 0.05);
  if (bbtShift) {
    coverline    = bbtShift.coverline;
    _postODeltas = bbtShift.postODeltas;
    _clMeta = {
      method: bbtShift.method,
      windowTemps: bbtShift.pre6Window,
      baseMax: bbtShift.pre6max,
      coverline
    };

    const dpo3_6 = _postODeltas.filter(x => x.dpo >= 3 && x.dpo <= 6).map(x => x.temp);
    if (dpo3_6.length >= 3) {
      const avg = a => a.reduce((s,v) => s + v, 0) / a.length;
      postOMean = avg(dpo3_6);
      risePreToDPO = postOMean - coverline;
    }
  }

  // Progesterone metrics (0.20°C rule)
  let pScore = null, pScoreDen = null, hasMultiDayDrop = null, sustainedShiftProg = null;
  if (_postODeltas.length) {
    const del = _postODeltas.filter(x => x.dpo >= 1 && x.dpo <= 10).sort((a,b) => a.dpo - b.dpo);
    pScoreDen = del.length;
    pScore    = del.filter(x => x.delta >= 0.20 - 1e-6).length;

    hasMultiDayDrop = del.some((x,i) => i>0 && del[i-1].delta < 0.20 - 1e-6 && x.delta < 0.20 - 1e-6);

    sustainedShiftProg = del.some((_,i) => {
      const slab = del.slice(i, i+4);
      return slab.length===4 && slab.filter(y => y.delta >= 0.20 - 1e-6).length >= 3;
    });
  }

  const lpdFromBBT = (pScoreDen!=null && pScoreDen>=6) ? ((pScore<6) || !!hasMultiDayDrop) : null;
  const lpdRisk = (lutealLen!=null && lutealLen<9) || (lpdFromBBT===true);

  const anovSuspect = !(lhNumSurgePresent && sustainedShiftProg===true);

  // Sex timing
  const sexCoverageCount = (()=>{ 
    if (!ovulationDate) return 0;
    const map = new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit = d => { const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    const arr=[ hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate) ];
    return arr.filter(Boolean).length;
  })();

  const sexDays = (()=>{ 
    if (!ovulationDate) return [false,false,false];
    const map=new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit=d=>{ const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    return [hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate)];
  })();

  const sexDays4 = (()=>{ 
    if (!ovulationDate) return [false,false,false,false];
    const map=new Map(segSorted.map(e=>[toUTCmid(e._date).getTime(), e]));
    const hit=d=>{ const ent=map.get(toUTCmid(d).getTime()); return !!(ent && String(ent.sex||'').toLowerCase()==='yes'); };
    return [hit(addDays(ovulationDate,-2)), hit(addDays(ovulationDate,-1)), hit(ovulationDate), hit(addDays(ovulationDate,1))];
  })();

  return {
    entries: seg,
    startDate, nextStart,
    length: dayDiff(startDate, nextStart),
    surgeDate, surgeCD,
    ovulationDate, lutealLen,
    fertileStart, fertileEnd,
    coverline, postOMean, risePreToDPO,
    clMeta: _clMeta,
    postODeltas: _postODeltas,
    pScore, pScoreDen, hasMultiDayDrop, sustainedShiftProg,
    lhNumSurgePresent, surgeNumDate,
    lpdRisk, anovSuspect,
    sexCoverageCount, sexDays, sexDays4
  };
}

function segmentCycles(entries){
  const byDate=entries.filter(e=>e._date instanceof Date && !isNaN(e._date)).sort((a,b)=>a._date - b._date);
  const idxDay1=[]; for(let i=0;i<byDate.length;i++) if(isDay1(byDate[i])) idxDay1.push(i);

  const cycles=[];

  if (idxDay1.length && idxDay1[0] > 0) {
    const startIdx = 0, nextIdx = idxDay1[0];
    const seg = byDate.slice(startIdx, nextIdx);
    const startDate = toUTCmid(byDate[startIdx]._date);
    const nextStart = toUTCmid(byDate[nextIdx]._date);
    if (dayDiff(startDate, nextStart) >= 2) cycles.push(buildCycle(seg, startDate, nextStart));
  }

  for(let c=0;c<idxDay1.length-1;c++){
    const startIdx=idxDay1[c], nextIdx=idxDay1[c+1];
    const seg=byDate.slice(startIdx, nextIdx);
    const startDate=toUTCmid(byDate[startIdx]._date);
    const nextStart=toUTCmid(byDate[nextIdx]._date);
    if(dayDiff(startDate,nextStart) >= 2) cycles.push(buildCycle(seg, startDate, nextStart));
  }
  return cycles;
}

/* ---------- Metrics & UI ---------- */
function computeMetrics(cycles){
  const mean=a=>a.length? a.reduce((x,y)=>x+y,0)/a.length : null;
  const sd=a=>{ if(a.length<2) return null; const mu=mean(a); return Math.sqrt(mean(a.map(x=>(x-mu)*(x-mu)))); };

  const lengths=cycles.map(c=>c.length);
  const luteals=cycles.map(c=>c.lutealLen).filter(v=>v!=null);
  const ovDays=cycles.filter(c=>c.ovulationDate).map(c=>dayDiff(c.startDate,c.ovulationDate)+1);
  const fertOffsets = cycles.filter(c=>c.fertileStart).map(c=>dayDiff(addDays(c.startDate,4), c.fertileStart));
  const fertLengths = cycles.filter(c=>c.fertileStart && c.fertileEnd).map(c=>dayDiff(c.fertileStart, c.fertileEnd)+1);

  const paired=cycles.filter(c=>c.coverline!=null && c.postOMean!=null);
  const cover=paired.map(c=>c.coverline);
  const postO=paired.map(c=>c.postOMean);

  const surgeCDs = cycles.map(c=>c.surgeCD).filter(v=>v!=null);
  function quantiles(arr){ if(!arr.length) return null; const a=arr.slice().sort((x,y)=>x-y);
    const q=p=>{ const i=(a.length-1)*p, lo=Math.floor(i), hi=Math.ceil(i); return lo===hi?a[lo]:a[lo]+(a[hi]-a[lo])*(i-lo); };
    return {median:q(0.5), q1:q(0.25), q3:q(0.75)}; }

  return {
    N:cycles.length,
    cycleLen:{mean:mean(lengths), sd:sd(lengths), N:lengths.length},
    fertileOffset:{mean:mean(fertOffsets), sd:sd(fertOffsets), N:fertOffsets.length},
    fertileLen:{mean:mean(fertLengths), sd:sd(fertLengths), N:fertLengths.length},
    ovulationDay:{mean:mean(ovDays), sd:sd(ovDays), N:ovDays.length},
    luteal:{mean:mean(luteals), sd:sd(luteals), N:luteals.length},
    coverline:{mean:mean(cover), sd:sd(postO), N:cover.length},
    postO:{mean:mean(postO), sd:sd(postO), N:postO.length},
    surge:{ cds: surgeCDs, q: quantiles(surgeCDs) }
  };
}

function renderCards(m){
  const cards=document.getElementById('cards');
  const f=(x,d)=>x==null?'—':(d===0? Math.round(x) : Number(x).toFixed(d));
  const r=(x)=>x==null?'—':Math.round(x);

  const it=(t,v,s)=>`<div class="card"><h3>${t}</h3><div class="value">${v}</div><div class="sub">${s||''}</div></div>`;
  cards.innerHTML=[
    it('Avg Cycle', `${r(m.cycleLen.mean)} d`, `±${f(m.cycleLen.sd,0)} (n=${m.cycleLen.N})`),
    it('Fertile Start', `${r(m.fertileOffset.mean)} d`, `after period (n=${m.fertileOffset.N})`),
    it('Fertile Length', `${f(m.fertileLen.mean,1)} d`, `±${f(m.fertileLen.sd,1)} (n=${m.fertileLen.N})`),
    it('Ovulation Day', `CD ${r(m.ovulationDay.mean)}`, `±${r(m.ovulationDay.sd)} (n=${m.ovulationDay.N})`),
    it('Luteal Length', `${r(m.luteal.mean)} d`, `±${r(m.luteal.sd)} (n=${m.luteal.N})`),
    it('Coverline (avg)', `${f(m.coverline.mean,2)} °C`, `n=${m.coverline.N}`),
    it('Post-O (avg)', `${f(m.postO.mean,2)} °C`, `n=${m.postO.N}`)
  ].join('');
}

function renderRibbons(cycles){
  const box=document.getElementById('ribbons'); box.innerHTML='';
  const completed=cycles.slice(-LAST_N);
  for(const c of completed){
    const unit=100/c.length; const bands=[];
    const p0=0, p1=Math.min(5,c.length); bands.push({left:p0*unit, width:(p1-p0)*unit, color:'var(--red)'});
    if(c.fertileStart && c.fertileEnd){
      const fs=dayDiff(c.startDate,c.fertileStart), fe=dayDiff(c.startDate,c.fertileEnd)+1;
      bands.push({left:fs*unit, width:(fe-fs)*unit, color:'var(--amber)'});
    }
    if(c.surgeDate){ const s=dayDiff(c.startDate,c.surgeDate); bands.push({left:s*unit, width:Math.max(1.5,unit*0.9), color:'var(--purple)'}); }
    if(c.ovulationDate){ const o=dayDiff(c.startDate,c.ovulationDate); bands.push({left:o*unit, width:Math.max(1.5,unit*0.9), color:'var(--blue)'}); }
    if(c.ovulationDate){ const o2=dayDiff(c.startDate,c.ovulationDate)+1; bands.push({left:o2*unit, width:(c.length-o2)*unit, color:'var(--green)'}); }
    const bandHTML=bands.map(b=>`<div class="band" style="left:${b.left}%;width:${b.width}%;background:${b.color}"></div>`).join('');
    const left=`${iso(c.startDate)} → ${iso(addDays(c.nextStart,-1))} · ${c.length}d`;
    const parts=[];
    if(c.coverline!=null) parts.push(`CL ${c.coverline.toFixed(2)}°C`);
    if(c.ovulationDate) parts.push(`O: CD ${dayDiff(c.startDate,c.ovulationDate)+1}`);
    if(c.lpdRisk) parts.push('LPD risk');
    if(c.anovSuspect) parts.push('Anov?');
    const right=parts.join(' · ') || '—';
    const url = `summary.html?cycle=${toUTCmid(c.startDate).getTime()}`;

    const div=document.createElement('a');
    div.className='ribbonLink';
    div.href=url;
    div.innerHTML=`<div class="ribbon"><div class="label"><span>${left}</span><span>${right}</span></div><div class="bar">${bandHTML}</div></div>`;
    box.appendChild(div);
  }
}

function renderInsights(cycles, m){
  const last = cycles.slice(-LAST_N);

  // Surge stats + strip
  const surgeStats = document.getElementById('surgeStats');
  const surgeNotes = document.getElementById('surgeNotes'); surgeNotes.innerHTML='';
  if(m.surge.q){
    const {median,q1,q3}=m.surge.q;
    surgeStats.textContent = `Median CD ${Math.round(median)} • IQR ${Math.round(q1)}–${Math.round(q3)} (n=${m.surge.cds.length})`;
  } else { surgeStats.textContent = 'No surge entries available'; }
  drawSurgeStrip(last);
  last.forEach((c)=>{ if(c.surgeCD==null){ const d=document.createElement('div'); d.innerHTML=`<span class="chip">${cycleMonthSpan(c)}</span> no numeric surge ≥ 0.75 / label`; surgeNotes.appendChild(d); }});

  // Post-O BBT dots vs coverline (full luteal)
  const riseList = document.getElementById('riseList'); 
  riseList.innerHTML = '';

  let totalDays = 0, totalHits = 0;

  last.forEach((c)=>{
    if (c.coverline == null || !Array.isArray(c.postODeltas) || !c.postODeltas.length) return;

    const maxDPO = (typeof c.lutealLen === 'number' && c.lutealLen > 0) 
      ? c.lutealLen 
      : Math.max(...c.postODeltas.map(x=>x.dpo));

    const days = c.postODeltas
      .filter(x => x.dpo >= 1 && x.dpo <= maxDPO)
      .sort((a,b)=>a.dpo - b.dpo);

    const squares = days.map(x=>{
      const d = x.delta; 
      const eps = 1e-6;
      const cls = (d >= 0.20 - eps) ? 'green' : (d > 0 + eps ? 'red' : 'base');
      const title = `DPO${x.dpo}: ${(d>=0?'+':'')}${d.toFixed(2)} °C vs CL ${(c.coverline!=null)?c.coverline.toFixed(2):'—'}°C`;
      return `<span class="bbtDot ${cls}" title="${title}"></span>`;
    }).join('');

    const hits = days.filter(x=>x.delta >= 0.20 - 1e-6).length;
    totalDays += days.length; 
    totalHits += hits;

    const flags = [];
    if (c.lpdRisk === true) flags.push('<span class="delta warn">LPD risk</span>');
    if (c.anovSuspect === true) flags.push('<span class="delta warn">Anov?</span>');

    const row = document.createElement('div');
    row.className = 'riseRow';
    row.innerHTML = `
      <span class="chip">${cycleMonthSpan(c)}</span>
      <div class="bbtBar">${squares}</div>
      <span class="delta ${hits>=6?'good':'warn'}">${hits}/${days.length} ≥ +0.20 °C</span>
      <span class="caption" style="margin-left:8px;color:var(--muted)">CL ${c.coverline!=null?c.coverline.toFixed(2):'—'}°C</span>
      ${flags.length ? `<span style="flex:1"></span>${flags.join('')}` : ''}
    `;
    riseList.appendChild(row);
  });

  const pct = totalDays ? Math.round(100 * totalHits / totalDays) : null;
  document.getElementById('riseStats').textContent = totalDays
    ? `${pct}% of luteal days ≥ +0.20 °C across shown cycles`
    : 'No post-O BBT data';

  // LPD matrix
  const lpdRows=[['Cycle','Luteal ≥ 9','DPO1–10 ≥ +0.20','No 2-day drop','No LPD risk']];
  last.forEach((c)=>{
    const lutealOK = (c.lutealLen!=null && c.lutealLen>=9) ? '✓' : '✗';
    const scoreText = (c.pScoreDen!=null) ? `${c.pScore}/${c.pScoreDen}` : '—';
    const noDrop = (c.hasMultiDayDrop==null) ? '—' : (c.hasMultiDayDrop? '✗' : '✓');
    const noRisk = (c.lpdRisk==null) ? '—' : (c.lpdRisk? '✗' : '✓');
    lpdRows.push([cycleMonthSpan(c), lutealOK, scoreText, noDrop, noRisk]);
  });
  renderMatrix('lpdMatrix', lpdRows);

  // Anovulation matrix
  const anovRows=[['Cycle','Numeric surge ≥ 0.75','Sustained shift (DPO1–10)','O inferred']];
  last.forEach((c)=>{
    const numOK = c.lhNumSurgePresent ? '✓' : '✗';
    const sustOK = (c.sustainedShiftProg==null) ? '—' : (c.sustainedShiftProg? '✓' : '✗');
    const inferred = (c.lhNumSurgePresent && c.sustainedShiftProg) ? '✓' : '✗';
    anovRows.push([cycleMonthSpan(c), numOK, sustOK, inferred]);
  });
  renderMatrix('anovMatrix', anovRows);

  // Sex timing
  const full3 = last.filter(c=>c.sexCoverageCount===3).length;
  const b0 = last.filter(c=>c.sexCoverageCount===0).length;
  const b1 = last.filter(c=>c.sexCoverageCount===1).length;
  const b2 = last.filter(c=>c.sexCoverageCount===2).length;
  const b3 = last.filter(c=>c.sexCoverageCount===3).length;
  document.getElementById('sexBreak').textContent = `0/3:${b0} • 1/3:${b1} • 2/3:${b2} • 3/3:${b3} • 100% hits: ${full3}/${last.length}`;

  const sexPills=document.getElementById('sexPills'); sexPills.innerHTML='';
  last.forEach((c)=>{
    const row=document.createElement('div'); row.className='pillRow';
    row.innerHTML = `<span class="chip">${cycleMonthSpan(c)}</span>
      <span class="pillLbl">-2</span><span class="dot ${c.sexDays4[0]?'on':''}"></span>
      <span class="pillLbl">-1</span><span class="dot ${c.sexDays4[1]?'on':''}"></span>
      <span class="pillLbl">0</span><span class="dot ${c.sexDays4[2]?'on':''}"></span>
      <span class="pillLbl">+1</span><span class="dot opt ${c.sexDays4[3]?'on':''}"></span>`;
    sexPills.appendChild(row);
  });
}

function drawSurgeStrip(cycles){
  const canvas=document.getElementById('surgeCanvas');
  const dpr=window.devicePixelRatio||1;
  const cssW=canvas.clientWidth, cssH=canvas.clientHeight;
  canvas.width=cssW*dpr; canvas.height=cssH*dpr;
  const ctx=canvas.getContext('2d'); ctx.scale(dpr,dpr);
  ctx.clearRect(0,0,cssW,cssH);

  const cds = cycles.map(c=>c.surgeCD).filter(v=>v!=null);
  let minCD = cds.length? Math.min(...cds) : 8;
  let maxCD = cds.length? Math.max(...cds) : 20;
  minCD=Math.max(6, Math.min(minCD, 12));
  maxCD=Math.min(28, Math.max(maxCD, 16));
  const left=36, right=cssW-12, center=cssH/2;

  ctx.strokeStyle="#ddd"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(left,center); ctx.lineTo(right,center); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font="11px system-ui"; ctx.textAlign="center";
  for(let cd=minCD; cd<=maxCD; cd+=2){
    const x = left + (cd-minCD)/(maxCD-minCD||1) * (right-left);
    ctx.beginPath(); ctx.moveTo(x, center-6); ctx.lineTo(x, center+6); ctx.stroke();
    ctx.fillText(String(cd), x, 14);
  }

  let row=0; const rows=3;
  cycles.forEach(c=>{
    const cd = c.surgeCD;
    if(cd==null) return;
    const x = left + (cd-minCD)/(maxCD-minCD||1) * (right-left);
    const y = center + ((row%rows)-1)*10; row++;
    ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fillStyle="rgba(209,95,167,0.9)"; ctx.fill();
  });
}

function renderMatrix(id, rows){
  const tbl=document.getElementById(id);
  let html='';
  rows.forEach((r,ri)=>{
    if(ri===0){
      html += '<tr>'+r.map(c=>`<th>${c}</th>`).join('')+'</tr>';
    }else{
      html += '<tr>'+r.map((c,ci)=>{
        if (ci===0) return `<td style="text-align:left">${c}</td>`;
        if (c==='✓') return `<td class="ok">✓</td>`;
        if (c==='✗') return `<td class="no">✗</td>`;
        return `<td>${c}</td>`;
      }).join('')+'</tr>';
    }
  });
  tbl.innerHTML=html;
}

/* ---------- Report (Share) ---------- */
/* ... your existing buildReportHTML & openReportWindow remain as in your last working version ... */
/* To keep this reply focused on the mobile + navigation changes, I didn’t alter the report logic below this point. */
function buildReportHTML(cycles, m, user){
  /* unchanged from your latest working version you pasted */
  /* (omitted here for brevity — keep the version that fixed peak OPK + print styles) */
  return '<!DOCTYPE html><html><body>Report generation is included in your working version.</body></html>';
}

function openReportWindow(cycles, metrics, user){
  const html = buildReportHTML(cycles, metrics, user);
  const w = window.open('', '_blank');
  if (!w) return alert('Popup blocked. Please allow popups to generate the report.');
  w.document.open(); w.document.write(html); w.document.close();
}

/* ---------- Orchestration ---------- */
let CURRENT_CYCLES=[];
let CURRENT_USER=null;

function renderAll(){
  if(!ENTRIES.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>No data</h3><div class="value">—</div><div class="sub">No entries</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  const cycles=segmentCycles(ENTRIES);
  if(!cycles.length){
    document.getElementById('cards').innerHTML='<div class="card"><h3>Setup</h3><div class="value">0 cycles</div><div class="sub">Add Day 1 (period start) entries.</div></div>';
    document.getElementById('ribbons').innerHTML='';
    return;
  }
  CURRENT_CYCLES=cycles;
  const m=computeMetrics(cycles);
  renderCards(m);
  renderRibbons(cycles);
  renderInsights(cycles, m);
  console.log('[history] surge CDs:', cycles.map(c=>c.surgeCD), 'lengths:', cycles.map(c=>c.length));
}

document.getElementById('homeBtn').addEventListener('click',()=>{ window.location.href='index.html'; });
document.getElementById('shareBtn').addEventListener('click', async ()=>{
  try{ CURRENT_USER = firebase.auth().currentUser || null; }catch{} 
  const m = computeMetrics(CURRENT_CYCLES||[]);
  openReportWindow(CURRENT_CYCLES||[], m, CURRENT_USER);
});
</script>
</body>
</html>
